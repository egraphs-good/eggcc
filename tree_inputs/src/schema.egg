; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  ; pointers cannot point to tuple types
  (PointerT Type)
  ; Nested tuple types are not allowed
  (TupleT TypeList) 
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)


; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Every expression can be thought of as a function with one argument.
; The argument to this expression.
; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg)) 1)` gets the second value in the argument with type (int, bool).
(function Arg () Expr)
(let arg (Arg))

; Constants
(datatype Constant
  (Int i64)
  (Bool bool))
(function Const (Constant) Expr)

; An empty tuple.
(function Empty () Expr)
; global short hand for (Empty)
(let empty (Empty))


; =================================
; Operators
; =================================
(datatype BinaryOp
  (Add)
  (Sub)
  (Mul)
  (LessThan)
  (And)
  (Or)
<<<<<<< HEAD
  ;; (address, value) -> Unit
  (Write))
=======
  ; given a pointer and a value, writes
  ; the value to the pointer
  (Write)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd))
>>>>>>> oflatt-input-schema-sugar
(datatype UnaryOp
  (Not)
  ; prints any non-tuple value
  ; returns an empty tuple
  (Print)
  ; given a pointer, loads the value at the pointer
  (Load))

; Operators
(function Bop   (BinaryOp Expr Expr) Expr)
(function Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(function Get   (Expr i64) Expr)
; allocate an integer amount of memory for a particular type
; returns a pointer to the allocated memory
(function Alloc (Expr Type)      Expr)
;               name of func   arg
(function Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Push` and `Extend` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Push` to add to the back of a tuple.
; 3. Use `Extend` to add one tuple to the back of another.
; Nested tuples are not allowed.


<<<<<<< HEAD
; Defines the order of evaluating a `Push` term.
(datatype Order
  ; evaluate in any order
  ; the program should reach an equivalent state either way
  (Parallel)
  ; evaluate the "value expr" first
=======
; Defines the order of evaluating an `Extend` term.
(datatype Order
  ; Either argument may be evaluated first.
  ; Either way, the program should reach an equivalent state.
  (Parallel)
  ; evaluate the first argument first
  ; e.g. `(Extend (Single a) (Single b))` evalutes to `(b, a)` with `a` evaluated first
>>>>>>> oflatt-input-schema-sugar
  (Sequential))

; global short hand for (Parallel)
(let par (Parallel))
; global short hand for (Sequential)
(let seq (Sequential))
(let rev (Reversed))

; A tuple with a single element.
; Necessary because we only use `Extend` to add to tuples.
(function Single (Expr) Expr)
; Extend adds `expr1` to the end of `tuple expr2` elementwise.
; e.g. (Extend (Parallel) (Extend (Sequential) (Single b) (Single a))
;                         (Extend (Sequential) (Single d) (Single c))) = (c, d, a, b)
; Extend keeps tuples flat, since nested tuples are not allowed.
;                 order   expr1       expr2
(function Extend (Order   Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; Does not create a region.
; pred must be an integer
;                 pred     branches     chosen
(function Switch (Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred then else
(function If (Expr Expr Expr) Expr)


; Creates a region, binding the input to `Arg`.
; e.g. `(Let (Extend new_tuple (Arg)) output)`
; binds argument to the old argument plus some new values `new_tuple`.
; 
;              input    output
(function Let (Expr     Expr)    Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; pred must be a boolean
;                  input   (pred, output1, output2, ..., outputi) tuple
(function DoWhile (Expr    Expr)                   Expr)




; =================================
; Assume
; =================================

(datatype Assumption
  ; The argument is bound to `expr`.
  ; The argument cannot be unioned with `expr` because `expr`
  ; is evaluated once at the nearest enclosing `Let`.
  ;      expr
  (InLet Expr)
  ; The term is in a loop with `input` and `output`.
  ;      input    output
  (InLoop Expr     Expr)
  ; Other assumptions are possible, but not supported yet.
  ; For example:
  ;      A boolean predicate is true.
  ;      e.g. (> (Arg) (Const (Int 2)))
  ; (IsTrue Expr))
)

; Assume allows creating context-specific terms.
; e.g. (Assume (InLet (Const (Int 2))) (Arg)) is equal to (Const (Int 2))
(function Assume (Assumption Expr) Expr)


; =================================
; Top-level expressions
; =================================
; An entry function and a list of additional functions.
;                      entry function     other functions
(relation Program     (Expr               ListExpr))
;                   name   input ty  output ty  output
(function Function (String Type      Type       Expr)      Expr)



; Rulesets
(ruleset always-run)
(ruleset error-checking)
