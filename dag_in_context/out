; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

; use TmpType for helpers where the type doesn't matter
; these shouldn't appear in values in the program, only intermediate terms (such as in ivt.egg permutations)
(constructor TmpType () Type)

(constructor TNil () TypeList)
(constructor TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Assumptions
; =================================

(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf bool Expr Expr)
)



; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(constructor Arg (Type Assumption) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool)
  (Float f64))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(constructor Const (Constant Type Assumption) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(constructor Empty (Type Assumption) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write)
  (Select))
(datatype BinaryOp
  ;; Bitwise operators
  (Bitand)
  ;; integer operators
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (Smin)
  (Smax)
  (Shl)
  (Shr)
  ;; float operators 
  (FAdd)
  (FSub)
  (FDiv)
  (FMul)
  (FLessThan)
  (FGreaterThan) 
  (FLessEq)
  (FGreaterEq)
  (FEq)
  (Fmin)
  (Fmax)
  ;; logical operators
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Neg)
  (Abs)
  (Not))

; Operators
(constructor Top   (TernaryOp Expr Expr Expr) Expr)
(constructor Bop   (BinaryOp Expr Expr) Expr)
(constructor Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(constructor Get   (Expr i64) Expr)
; (Alloc id amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns (pointer to the allocated memory, state edge)
(constructor Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(constructor Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(constructor Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 expr1       expr2
(constructor Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; pred must be an integer
;                 pred  inputs   branches     chosen
(constructor Switch (Expr  Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred inputs   then else
(constructor If (Expr Expr     Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple 
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(constructor DoWhile (Expr    Expr)                   Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(constructor Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(constructor Function (String Type      Type       Expr)      Expr)

; to get the type of a funciton, look in this table
; since we might not be optimizing the entire program
(relation FunctionHasType (String Type Type))

; Rulesets
(ruleset always-run)
(ruleset is-resolved)
(ruleset error-checking)
(ruleset memory)
(ruleset memory-helpers)
(ruleset smem)

;; Initliazation
(relation bop->string (BinaryOp String))
(relation uop->string (UnaryOp String))
(relation top->string (TernaryOp String))
(bop->string (Add) "Add")
(bop->string (Sub) "Sub")
(bop->string (Div) "Div")
(bop->string (Mul) "Mul")
(bop->string (LessThan) "LessThan")
(bop->string (GreaterThan) "GreaterThan")
(bop->string (LessEq) "LessEq")
(bop->string (GreaterEq) "GreaterEq")
(bop->string (Eq) "Eq")
(bop->string (FAdd) "FAdd")
(bop->string (FSub) "FSub")
(bop->string (FDiv) "FDiv")
(bop->string (FMul) "FMul")
(bop->string (FLessThan) "FLessThan")
(bop->string (FGreaterThan) "FGreaterThan")
(bop->string (FLessEq) "FLessEq")
(bop->string (FGreaterEq) "FGreaterEq")
(bop->string (FEq) "FEq")
(bop->string (And) "And")
(bop->string (Or) "Or")
(bop->string (Load) "Load")
(bop->string (PtrAdd) "PtrAdd")
(bop->string (Print) "Print")
(bop->string (Free) "Free")

;; If anything is put in the DebugExpr relation, we'll extract them instead of the original program.
;; These can then be visualized using the `optimized-rvsdg` run mode
(relation DebugExpr (Expr))

; TERMS
(datatype Term)
(datatype ListTerm (TermCons Term ListTerm) (TermNil))

; TODO: Will probably need ctx so that we can resubstitute?
; (datatype TermAssumption
;   ; Assume nothing
;   (InFunc String)
;   ; The term is in a loop with `input` and `pred_output`.
;   ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
;   ;      input    pred_output
;   (InLoop Term     Term)
;   ; Branch of the switch, and what the predicate is, and what the input is
;   (InSwitch i64 Term Term)
;   ; If the predicate was true, and what the predicate is, and what the input is
;   (InIf bool Term Term)
; )

(constructor TermArg () Term)

(constructor TermConst (Constant) Term)

(constructor TermEmpty () Term)

; Term Operators
(constructor TermTop (TernaryOp Term Term Term) Term)
(constructor TermBop (BinaryOp Term Term) Term)
(constructor TermUop (UnaryOp Term) Term)
(constructor TermGet (Term i64) Term)
(constructor TermAlloc (i64 Term Term BaseType) Term)
(constructor TermCall (String Term) Term)

; Tuple Operators
(constructor TermSingle (Term) Term)
(constructor TermConcat (Term Term) Term)

; Control Flow (TODO? Not sure if needed)
; (constructor TermSwitch (Term Term ListTerm) Term)
; (constructor TermIf (Term Term Term Term) Term)

; (constructor TermDoWhile (Term Term) Term)


(ruleset never)
(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(constructor TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64 :no-merge)
(constructor TypeList-ith (TypeList i64) BaseType :unextractable)
;; Don't match on TypeList-ith because it is now lazily instantiated!
(rule () ((set (TypeList-length (TNil)) 0)) :ruleset type-helpers)
(rule ((= lst (TCons hd tl))
       (= len (TypeList-length tl)))
      ((set (TypeList-length lst) (+ 1 len))) :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) 0) hd :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) i) (TypeList-ith tl (- i 1)) 
      :when ((> i 0)) 
      :ruleset type-helpers)

(rule ((TypeList-ith list i)
       (= (TypeList-length list) n)
       (>= i n))
      ((panic "TypeList-ith out of bounds")) :ruleset type-helpers)

(relation HasType (Expr Type))


;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      ((extract "Expecting expression")
       (extract e)
       (extract "to have type")
       (extract expected)
       (extract "but got type")
       (extract actual)
       (extract "with message")
       (extract msg)
       (panic "type mismatch- check RUST_LOG=info for expressions that mismatched"))
      :ruleset error-checking)


(rule ((= (Const c1 ty1 ctx1) (Const c2 ty2 ctx2))
       (= ctx1 (InFunc name))
       (!= c1 c2))
      ((panic "Unsoundness detected: const values differ at top level"))
      :ruleset error-checking)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1 ctx) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset error-checking)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset error-checking)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType branch ty)
       (HasType inputs ty2)
       (!= ty ty2))
      ((panic "switch branches then branch has incorrect input type"))
      :ruleset error-checking)
;; demand with one fewer branches
(rule ((= lhs (Switch pred inputs (Cons branch rest))))
      ((Switch pred inputs rest))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType t ty2)
       (!= ty ty2))
      ((panic "if branches then branch has incorrect input type"))
      :ruleset error-checking)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType e ty2)
       (!= ty ty2))
      ((panic "if branches else branch has incorrect input type"))
      :ruleset error-checking)


(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty ctx)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty ctx)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Float b) ty ctx)))
      ((HasType lhs (Base (FloatT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty ctx)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not)"))
      :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
      (HasType e (Base (IntT)))
) (
      (HasType lhs (Base (IntT)))
) :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
) (
      (ExpectType e (Base (IntT)) "(Neg)")
) :ruleset type-analysis)

(rule (
        (= lhs (Uop (Abs) e))
        (HasType e (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Abs) e)))
      ((ExpectType e (Base (IntT)) "(Abs)"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset error-checking)

(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset error-checking)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset error-checking)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Top (Select) pred v1 v2))
      )
      ((ExpectType pred (Base (BoolT)) "(Select)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty)
        (HasType v2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty1)
        (HasType v2 ty2)
        (!= ty1 ty2)
      )
      ((panic "(Select) branches had different types"))
      :ruleset error-checking)


; Binary ops

;; Operators that have type Type -> Type -> Type
;; Note we only do this generic matching for binary
;; operator since there's a lot of them.
;; In the future we can also extend to other constructs.
(relation bop-of-type (BinaryOp Type))
(bop-of-type (Bitand) (Base (IntT)))
(bop-of-type (Add) (Base (IntT)))
(bop-of-type (Sub) (Base (IntT)))
(bop-of-type (Div) (Base (IntT)))
(bop-of-type (Mul) (Base (IntT)))
(bop-of-type (FAdd) (Base (FloatT)))
(bop-of-type (FSub) (Base (FloatT)))
(bop-of-type (FDiv) (Base (FloatT)))
(bop-of-type (FMul) (Base (FloatT)))

(rule (
        (= lhs (Bop op e1 e2))
        (bop-of-type op ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop op e1 e2))
       (bop-of-type op ty)
       (bop->string op op-str))
      (
        (ExpectType e1 ty op-str)
        (ExpectType e2 ty op-str)
      )
      :ruleset type-analysis)  

;; Operators that have type Float -> Float -> Bool
(relation bpred-of-type (BinaryOp Type))
(bpred-of-type (FLessThan) (Base (FloatT)))
(bpred-of-type (FLessEq) (Base (FloatT)))
(bpred-of-type (FGreaterThan) (Base (FloatT)))
(bpred-of-type (FGreaterEq) (Base (FloatT)))
(bpred-of-type (FEq) (Base (FloatT)))
(bpred-of-type (LessThan) (Base (IntT)))
(bpred-of-type (LessEq) (Base (IntT)))
(bpred-of-type (GreaterThan) (Base (IntT)))
(bpred-of-type (GreaterEq) (Base (IntT)))
(bpred-of-type (Eq) (Base (IntT)))
(bpred-of-type (And) (Base (BoolT)))
(bpred-of-type (Or) (Base (BoolT)))

(rule (
        (= lhs (Bop pred e1 e2))
        (bpred-of-type pred ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop pred e1 e2))
       (bpred-of-type pred ty)
       (bop->string pred pred-str))
      (
        (ExpectType e1 ty pred-str)
        (ExpectType e2 ty pred-str)
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base ty)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write)"))
      :ruleset type-analysis)
      
       

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i)))) 
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset error-checking)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset error-checking)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset error-checking)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred inputs then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset error-checking)



(rule ((= lhs (Switch pred inputs branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred inputs (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred inputs (Cons branch rest)))
      ((Switch pred inputs rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred inputs rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred inputs rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset error-checking)

(rule ((Arg ty ctx))
      (
        (HasType (Arg ty ctx) ty)
        (HasArgType (Arg ty ctx) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset error-checking)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; find which types are pure
(relation PureBaseType (BaseType))
(relation PureType (Type))
(relation PureTypeList (TypeList))

(PureBaseType (IntT))
(PureBaseType (BoolT))
(rule ((Base ty)
       (PureBaseType ty))
      ((PureType (Base ty)))
      :ruleset type-analysis)
(rule ((TupleT tylist)
       (PureTypeList tylist))
      ((PureType (TupleT tylist)))
      :ruleset type-analysis)
(rule ((TNil))
      ((PureTypeList (TNil)))
      :ruleset type-analysis)
(rule ((TCons hd tl)
       (PureBaseType hd)
       (PureTypeList tl))
      ((PureTypeList (TCons hd tl)))
      :ruleset type-analysis)

(function ListExpr-length (ListExpr) i64 :no-merge)
(constructor ListExpr-ith (ListExpr i64) Expr :unextractable)
(constructor ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(constructor Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred inputs branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :no-merge)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)


;; Leading expressions are tuples that are used as a whole
;; during optimization and are matched in the query.
(relation leading-Expr (Expr))
(relation leading-Expr-list (ListExpr))

(rule ((= e (DoWhile inputs pred_out)))
      ((leading-Expr e)
       (leading-Expr inputs)
       (leading-Expr pred_out))
      :ruleset always-run)
(rule ((= e (If cond inputs thn els)))
       ((leading-Expr e)
        (leading-Expr inputs)
        (leading-Expr thn)
        (leading-Expr els))
       :ruleset always-run)
(rule ((= e (Switch pred inputs branch)))
      ((leading-Expr e)
       (leading-Expr-list branch)
       (leading-Expr inputs))
       :ruleset always-run)
(rule ((leading-Expr-list (Cons hd tl)))
      ((leading-Expr hd)
       (leading-Expr-list tl))
      :ruleset always-run)
(rule ((= e (Arg t a)))
      ((leading-Expr e))
      :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((leading-Expr tuple)
       (> (tuple-length tuple) 0))
      ((Get tuple 0))
      :ruleset always-run)
;; next get
(rule ((leading-Expr tuple)
       (= len (tuple-length tuple))
       (= ith (Get tuple i))
       (< (+ i 1) len)
       )
       ((Get tuple (+ 1 i)))
       :ruleset always-run)

(constructor List-suffix (Expr i64) Expr)
(rule ((Get x i))
      ((union (List-suffix x 0) x))
      :ruleset always-run)
(rule ((= (List-suffix x n) (Concat (Single hd) tl)))
      ((union (List-suffix x (+ n 1)) tl))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Concat (Single e) rest)))
      ((union lhs e))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Single e)))
      ((union lhs e))
      :ruleset always-run)

;; A temporary context.
;; Be sure to delete at the end of all actions or else!!!
;; This is safer than using a persistant context, since we may miss an important part of the query.
(constructor TmpCtx () Assumption)

(rule ((TmpCtx))
  ((panic "TmpCtx should not exist outside rule body"))
  :ruleset always-run)


(ruleset subsume-after-helpers)
;; After running the `saturating` ruleset, these if statements can be subsumed
(relation ToSubsumeIf (Expr Expr Expr Expr))
;; Workaround of https://github.com/egraphs-good/egglog/issues/462
;; Make sure the if we are subsuming is present
(rule ((ToSubsumeIf a b c d)
       (If a b c d))
      ((subsume (If a b c d)))
      :ruleset subsume-after-helpers)

(ruleset add-to-debug-expr)

(ruleset terms)
;; helpers keeps track of the new best extracted terms
(ruleset terms-helpers)
;; helpers-helpers runs `Smaller` rules, resolving the merge function for helpers
(ruleset terms-helpers-helpers)

(sort TermAndCost)
(constructor Smaller (TermAndCost TermAndCost) TermAndCost)

(function ExtractedExpr (Expr) TermAndCost
  :merge (Smaller old new))
;; potential extractions- use so that when the costs are equal, we don't change the term
;; this preserves egglog's timestamp of when the last time ExtractedExpr was changed, fixing a big performance problem
(relation PotentialExtractedExpr (Expr TermAndCost))

(constructor TCPair (Term i64) TermAndCost)

(constructor NoTerm () Term)

;; set extracted expr to default value
(rule ((PotentialExtractedExpr expr termandcost))
      ((set (ExtractedExpr expr) (TCPair (NoTerm) 10000000000000000)))
      :ruleset terms-helpers)

;; set extracted expr to new value as long as not equal
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (= (ExtractedExpr expr) (TCPair oldterm oldcost))
       (< cost oldcost))
      ((set (ExtractedExpr expr) (TCPair term cost)))
      :ruleset terms-helpers)

;; if the cost is negative panic, terms got too big
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (< cost 0))
      ((panic "Negative cost"))
      :ruleset terms-helpers)

;; Resolve Smaller
(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (< cost1 cost2)
      )
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)

(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (> cost1 cost2) 
      )
      ((union lhs (TCPair t2 cost2)))
      :ruleset terms-helpers-helpers)


(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (= cost1 cost2) 
      )
      ;; arbitrarily pick first one
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)


; Compute smallest Expr bottom-up
(rule ((= lhs (Const c ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermConst c) 1)))
      :ruleset terms)

(rule ((= lhs (Arg ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermArg) 1)))
      :ruleset terms)

(rule (
        (= lhs (Bop o e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermBop o t1 t2) (+ 1 (+ c1 c2)))))
      :ruleset terms)

(rule (
        (= lhs (Top o e1 e2 e3))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (= (TCPair t3 c3) (ExtractedExpr e3))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermTop o t1 t2 t3) (+ (+ 1 c1) (+ c2 c3)))))
      :ruleset terms)

(rule (
        (= lhs (Uop o e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermUop o t1) (+ 1 c1))))
      :ruleset terms)

(rule (
        (= lhs (Get tup i))
        (= (TCPair t1 c1) (ExtractedExpr tup))
      )
      ; cost of the get is the same as the  cost of the whole tuple
      ((PotentialExtractedExpr lhs (TCPair (TermGet t1 i) c1)))
      :ruleset terms)

; todo Alloc

; todo Call

(rule (
        (= lhs (Single e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ; cost of single is same as cost of the element
      ((PotentialExtractedExpr lhs (TCPair (TermSingle t1) c1)))
      :ruleset terms)

(rule (
        (= lhs (Concat e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ; cost of concat is sum of the costs
      ((PotentialExtractedExpr lhs (TCPair (TermConcat t1 t2) (+ c1 c2))))
      :ruleset terms)


; todo Control flow - not sure if needed
; (rule (
;         (= lhs (If pred inputs thn els))
;         (= (TCPair t1 c1) (ExtractedExpr pred))
;         (= (TCPair t2 c2) (ExtractedExpr inputs))
;         (= (TCPair t3 c3) (ExtractedExpr thn))
;         (= (TCPair t4 c4) (ExtractedExpr els))
;       )
;       ; cost of if is 10 + cost of pred + cost of input + max of branch costs
;       ((PotentialExtractedExpr lhs (TCPair (TermIf t1 t2 t3 t4) (+ 10 (+ (+ c1 c2) (max c3 c4))))))
;       :ruleset terms)

(sort Node)
;; store a particular if node for later
;; stored as the if eclass, pred, inputs, then, else
(constructor IfNode (Expr Expr Expr Expr Expr) Node)

(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Function _name _tyin _tyout _out))) ((ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Top _op _x _y _z))) ((ExprIsValid _x)
(ExprIsValid _y)
(ExprIsValid _z)) :ruleset always-run)
(rule ((ExprIsValid (Bop _op _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Uop _op _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Concat _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Single _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _inputs _branches))) ((ExprIsValid _pred)
(ExprIsValid _inputs)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (If _pred _input _then _else))) ((ExprIsValid _pred)
(ExprIsValid _input)
(ExprIsValid _then)
(ExprIsValid _else)) :ruleset always-run)
(rule ((ExprIsValid (DoWhile _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Call _func _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(rule ((ExprIsValid (Alloc _id _e _state _ty))) ((ExprIsValid _e)
(ExprIsValid _state)) :ruleset always-run)
(relation ExprIsResolved (Expr))
(relation ListExprIsResolved (ListExpr))
(rule ((= lhs (Function _name _tyin _tyout _out)) (ExprIsResolved _out)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Const _n _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Top _op _x _y _z)) (ExprIsResolved _x)
(ExprIsResolved _y)
(ExprIsResolved _z)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Bop _op _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Uop _op _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Get _tup _i)) (ExprIsResolved _tup)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Concat _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Single _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Switch _pred _inputs _branches)) (ExprIsResolved _pred)
(ExprIsResolved _inputs)
(ListExprIsResolved _branches)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (If _pred _input _then _else)) (ExprIsResolved _pred)
(ExprIsResolved _input)
(ExprIsResolved _then)
(ExprIsResolved _else)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (DoWhile _in _pred-and-output)) (ExprIsResolved _in)
(ExprIsResolved _pred-and-output)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Arg _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Call _func _arg)) (ExprIsResolved _arg)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Empty _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Cons _hd _tl)) (ExprIsResolved _hd)
(ListExprIsResolved _tl)) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Nil)) ) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Alloc _id _e _state _ty)) (ExprIsResolved _e)
(ExprIsResolved _state)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(relation BodyContainsExpr (Expr Expr))
(relation BodyContainsListExpr (Expr ListExpr))
(rule ((Function _name _tyin _tyout _out)) ((BodyContainsExpr (Function _name _tyin _tyout _out) _out)) :ruleset always-run)
(rule ((If _pred _input _then _else)) ((BodyContainsExpr (If _pred _input _then _else) _then) (BodyContainsExpr (If _pred _input _then _else) _else)) :ruleset always-run)
(rule ((DoWhile _in _pred-and-output)) ((BodyContainsExpr (DoWhile _in _pred-and-output) _pred-and-output)) :ruleset always-run)
(rule ((BodyContainsExpr body (Top _op _x _y _z))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y) (BodyContainsExpr body _z)) :ruleset always-run)
(rule ((BodyContainsExpr body (Bop _op _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Uop _op _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Get _tup _i))) ((BodyContainsExpr body _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body (Concat _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Single _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Switch _pred _inputs _branches))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _inputs)) :ruleset always-run)
(rule ((BodyContainsExpr body (If _pred _input _then _else))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _input)) :ruleset always-run)
(rule ((BodyContainsExpr body (DoWhile _in _pred-and-output))) ((BodyContainsExpr body _in)) :ruleset always-run)
(rule ((BodyContainsExpr body (Call _func _arg))) ((BodyContainsExpr body _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body (Cons _hd _tl))) ((BodyContainsExpr body _hd)) :ruleset always-run)
(rule ((BodyContainsExpr body (Alloc _id _e _state _ty))) ((BodyContainsExpr body _e) (BodyContainsExpr body _state)) :ruleset always-run)
(relation ExprIsPure (Expr))
(relation ListExprIsPure (ListExpr))
(relation BinaryOpIsPure (BinaryOp))
(relation UnaryOpIsPure (UnaryOp))
(relation TernaryOpIsPure (TernaryOp))
(TernaryOpIsPure (Select))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (Smax))
(BinaryOpIsPure (Smin))
(BinaryOpIsPure (Shl))
(BinaryOpIsPure (Shr))
(BinaryOpIsPure (FAdd))
(BinaryOpIsPure (FSub))
(BinaryOpIsPure (FMul))
(BinaryOpIsPure (FDiv))
(BinaryOpIsPure (FEq))
(BinaryOpIsPure (FLessThan))
(BinaryOpIsPure (FGreaterThan))
(BinaryOpIsPure (FLessEq))
(BinaryOpIsPure (FGreaterEq))
(BinaryOpIsPure (Fmax))
(BinaryOpIsPure (Fmin))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(BinaryOpIsPure (Bitand))
(UnaryOpIsPure (Not))
(UnaryOpIsPure (Abs))
(UnaryOpIsPure (Neg))

(rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
        ((ExprIsPure (Function _name _tyin _tyout _out)))
        :ruleset always-run)

(rule ((Const _n _ty _ctx))
        ((ExprIsPure (Const _n _ty _ctx)))
        :ruleset always-run)

(rule ((Top _op _x _y _z) (TernaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
        ((ExprIsPure (Top _op _x _y _z)))
        :ruleset always-run)

(rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Bop _op _x _y)))
        :ruleset always-run)

(rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
        ((ExprIsPure (Uop _op _x)))
        :ruleset always-run)

(rule ((Get _tup _i) (ExprIsPure _tup))
        ((ExprIsPure (Get _tup _i)))
        :ruleset always-run)

(rule (
        (= lhs (Get (Arg (TupleT tylist) _ctx) i))
        (!= (TypeList-ith tylist i) (StateT))
      )
      ((ExprIsPure lhs))
      :ruleset always-run)

(rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Concat _x _y)))
        :ruleset always-run)

(rule ((Single _x) (ExprIsPure _x))
        ((ExprIsPure (Single _x)))
        :ruleset always-run)

(rule ((Switch _pred _inputs _branches) (ExprIsPure _pred) (ExprIsPure _inputs) (ListExprIsPure _branches))
        ((ExprIsPure (Switch _pred _inputs _branches)))
        :ruleset always-run)

(rule ((If _pred _input _then _else) (ExprIsPure _pred) (ExprIsPure _input) (ExprIsPure _then) (ExprIsPure _else))
        ((ExprIsPure (If _pred _input _then _else)))
        :ruleset always-run)

(rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
        ((ExprIsPure (DoWhile _in _pred-and-output)))
        :ruleset always-run)

; state edge is not pure!
; (rule ((Arg _ty _ctx))
;         ((ExprIsPure (Arg _ty _ctx)))
;         :ruleset always-run)

(rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
        ((ExprIsPure (Call _f _arg)))
        :ruleset always-run)

(rule ((Empty _ty _ctx))
        ((ExprIsPure (Empty _ty _ctx)))
        :ruleset always-run)

(rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
        ((ListExprIsPure (Cons _hd _tl)))
        :ruleset always-run)

(rule ((Nil))
        ((ListExprIsPure (Nil)))
        :ruleset always-run)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)

(constructor AddContext (Assumption Expr) Expr :unextractable)
(constructor AddContextList (Assumption ListExpr) ListExpr :unextractable)

;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (AddContext ctx inner))
   (= inner (AddContext ctx expr)))
  ((union lhs inner))
  :ruleset context)


;; ############################## Base cases- leaf nodes

;; replace existing contexts that are around leaf nodes
;; AddContext assumes the new context is more specific than the old one
(rule ((= lhs (AddContext ctx (Arg ty oldctx))))
      ((union lhs (Arg ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Const c ty oldctx))))
      ((union lhs (Const c ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Empty ty oldctx))))
      ((union lhs (Empty ty ctx)))
      :ruleset context)




;; ######################################### Operators
(rewrite (AddContext ctx (Top op c1 c2 c3))
         (Top op
           (AddContext ctx c1)
           (AddContext ctx c2)
           (AddContext ctx c3))
               :ruleset context)
(rewrite (AddContext ctx (Bop op c1 c2))
         (Bop op
           (AddContext ctx c1)
           (AddContext ctx c2))
               :ruleset context)
(rewrite (AddContext ctx (Uop op c1))
         (Uop op (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Get c1 index))
         (Get (AddContext ctx c1) index)
               :ruleset context)
(rewrite (AddContext ctx (Alloc id c1 state ty))
         (Alloc id (AddContext ctx c1) (AddContext ctx state) ty)
         :ruleset context)
(rewrite (AddContext ctx (Call name c1))
         (Call name (AddContext ctx c1))
         :ruleset context)

(rewrite (AddContext ctx (Single c1))
         (Single (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Concat c1 c2))
         (Concat
           (AddContext ctx c1)
           (AddContext ctx c2))
         :ruleset context)

;; ################################### List operators

(rewrite (AddContextList ctx (Nil))
         (Nil)
         :ruleset context)

(rewrite (AddContextList ctx (Cons c1 rest))
         (Cons (AddContext ctx c1)
               (AddContextList ctx rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (AddContext ctx (Switch pred inputs branches))
         (Switch (AddContext ctx pred)
                 (AddContext ctx inputs)
                 branches)
         :ruleset context)

;; For stop at region, still add context to inputs
(rule ((= lhs (AddContext ctx (If pred inputs c1 c2))))
      ((union lhs
         (If (AddContext ctx pred)
             (AddContext ctx inputs)
             c1
             c2)))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (AddContext ctx (DoWhile inputs outputs))))
      ((union lhs
        (DoWhile
          (AddContext ctx inputs)
          outputs)))
       :ruleset context)


(ruleset term-subst)


; Instantiate the term as an Expr in the provided context
; where references to (Arg) in the term are replaced by Expr
(constructor TermSubst (Assumption Expr Term) Expr :unextractable)

; type rule to get the arg type of a substitution
(rule (
        (= lhs (TermSubst ctx e1 term))
        (HasArgType e1 ty)       
      )
      ((HasArgType lhs ty))
      :ruleset term-subst)


; leaf node
; replace the context
(rule ((= lhs (TermSubst ctx e (TermArg))))
      ((union lhs (AddContext ctx e)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConst c)))
       (HasArgType e newty))
      ((union lhs (Const c newty ctx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermEmpty)))
       (HasArgType e newty))
      ((union lhs (Empty newty ctx)))
      :ruleset term-subst)

; Operators
(rule ((= lhs (TermSubst ctx e (TermTop op t1 t2 t3))))
      ((union lhs (Top op (TermSubst ctx e t1)
                          (TermSubst ctx e t2)
                          (TermSubst ctx e t3))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermBop op t1 t2))))
      ((union lhs (Bop op (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermUop op t1))))
      ((union lhs (Uop op (TermSubst ctx e t1))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermGet t idx))))
      ((union lhs (Get (TermSubst ctx e t) idx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermAlloc id t1 t2 ty))))
      ((union lhs (Alloc id (TermSubst ctx e t1)
                            (TermSubst ctx e t2)
                            ty)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermCall name t))))
      ((union lhs (Call name (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermSingle t))))
      ((union lhs (Single (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConcat t1 t2))))
      ((union lhs (Concat (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

; Control Flow
; TODO
;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(constructor Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(constructor DelayedSubstUnion (Expr Expr) Expr :unextractable)

;; add a type rule to get the arg type of a substitution
;; this enables nested substitutions
(rule ((= lhs (Subst assum to in))
       (HasArgType to ty))
      ((HasArgType lhs ty))
      :ruleset subst)

;; Substitution typechecks only when the type of the
;; argument matches the type of the substitution.
(rule ((Subst assum to in)
       (HasArgType in ty)
       (HasType to ty2)
       (!= ty ty2)
       ;; tmptype disables typechecking
       (!= ty (TmpType))
       (!= ty2 (TmpType)))
      ((extract "Extracting type mismatch")
       (extract ty)
       (extract ty2)
       (panic "Substitution type mismatch! Argument type must match type of substituted term"))
       :ruleset subst)


;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to e))
       (= e (Arg _ty _oldctx))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Const c _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Const c newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Empty _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Empty newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)

;; Operators
(rule ((= e (Top op c1 c2 c3))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Top op (Subst assum to c1)
                 (Subst assum to c2)
                 (Subst assum to c3)))
       (subsume (Subst assum to e)))
         :ruleset subst)

(rule ((= e (Bop op c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Bop op (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Uop op c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Uop op (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)    

(rule ((= e (Get c1 index))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Get (Subst assum to c1) index))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Alloc id c1 c2 ty))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Alloc id (Subst assum to c1)
                   (Subst assum to c2)
                   ty))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Call name c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Call name (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)


;; Tuple operators
(rule ((= e (Single c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Single (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Concat c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Concat (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)

;; Control flow
(rule ((= lhs (Subst assum to inner))
       (= inner (Switch pred inputs c1))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 c1))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= lhs (Subst assum to inner))
       (= inner (If pred inputs c1 c2))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= e (DoWhile in out))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (DoWhile (Subst assum to in)
                  out))
       (subsume (Subst assum to e)))
      :ruleset subst)

;; substitute into function (convenience for testing)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :when ((ExprIsResolved body))
         :ruleset subst)



;; ########################### Apply subst unions

(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)

; We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

(rule ((Arg ty ctx))
      ((ContextOf (Arg ty ctx) ctx))
      :ruleset always-run)
(rule ((Const c ty ctx))
      ((ContextOf (Const c ty ctx) ctx))
      :ruleset always-run)
(rule ((Empty ty ctx))
      ((ContextOf (Empty ty ctx) ctx))
        :ruleset always-run)

; Error checking - each expr should only have a single context
(rule ((ContextOf x ctx1)
       (ContextOf x ctx2)
       (!= ctx1 ctx2))
     (
         (panic "Equivalent expressions have nonequivalent context, breaking the single context invariant.")
     )
     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred inputs branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred inputs branches) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf pred ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((If pred inputs then else) (ContextOf inputs ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(ruleset canon)

; Commutativity
(rewrite (Bop (Add) x y) (Bop (Add) y x) :ruleset canon)
(rewrite (Bop (Mul) x y) (Bop (Mul) y x) :ruleset canon)
(rewrite (Bop (Eq) x y) (Bop (Eq) y x) :ruleset canon)
(rewrite (Bop (And) x y) (Bop (And) y x) :ruleset canon)
(rewrite (Bop (Or) x y) (Bop (Or) y x) :ruleset canon)

; Canonicalize to <
; x > y ==> y < x
(rewrite (Bop (GreaterThan) x y) (Bop (LessThan) y x) :ruleset canon)

; x >= y ==> y < x + 1
; x >= y ==> y - 1 < x
(rule (
        (= lhs (Bop (GreaterEq) x y))
        (HasArgType x ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) y (Bop (Add) x (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) y (Const (Int 1) ty ctx)) x))
      )
      :ruleset canon)

; x <= y ==> x < y + 1
; x <= y ==> x - 1 < y
(rule (
        (= lhs (Bop (LessEq) x y))
        (HasArgType y ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) x (Bop (Add) y (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) x (Const (Int 1) ty ctx)) y))
      )
      :ruleset canon)


; Make Concats right-deep
(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)
; Simplify Concat's with empty
(rewrite (Concat (Empty ty ctx) x)
         x
         :ruleset always-run)
(rewrite (Concat x (Empty ty ctx))
         x
         :ruleset always-run)

; Make a tuple that is a sub-range of another tuple
;                   tuple start len
(constructor SubTuple (Expr  i64   i64) Expr :unextractable)

(rewrite (SubTuple expr x 0)
         (Empty ty ctx)
         :when ((HasArgType expr ty) (ContextOf expr ctx))
         :ruleset always-run)

(rewrite (SubTuple expr x 1)
         (Single (Get expr x))
         :ruleset always-run)

(rewrite (SubTuple expr a b)
         (Concat (Single (Get expr a)) (SubTuple expr (+ a 1) (- b 1)))
         :when ((> b 1))
         :ruleset always-run)

; Some of our rules (like ivt.egg) match on `Concat`.
; These may be missing if a tuple is used directly (i.e. (DoWhile inputs (If pred thn else))).
; So add these concats for every region in the database
(rule ((= lhs (DoWhile inputs body))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (If pred inputs thn els))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Switch pred inputs bodies))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Arg ty ctx))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)

; Also figure out what existing expressions are subtuples of other things
; this helps remove concat layers
(rule ((Get expr i))
      ((union (Single (Get expr i))
              (SubTuple expr i 1)))
      :ruleset always-run)

(rewrite (Concat (SubTuple expr a b)
                 (SubTuple expr (+ a b) c))
         (SubTuple expr a (+ b c))
         :ruleset always-run)
;; a subtuple which is the entire tuple is the tuple itself
;; this removes unecessary layers of concat
(rewrite (SubTuple expr 0 len)
         expr
         :when ((= len (tuple-length expr)))
         :ruleset always-run)

; Helper functions to remove one element from a tuple or type list
;                           tuple    idx
(constructor TupleRemoveAt    (Expr     i64) Expr     :unextractable)
(rewrite (TupleRemoveAt tuple idx)
         (Concat (SubTuple tuple 0 idx)
                 (SubTuple tuple (+ idx 1) (- len (+ idx 1))))
         :when ((= len (tuple-length tuple)))
         :ruleset always-run)
(rule ((TupleRemoveAt tuple idx)
       (= len (tuple-length tuple))
       (>= idx len))
      ((panic "Index out of bounds for TupleRemoveAt")) :ruleset always-run)

(constructor TypeListRemoveAt (TypeList i64) TypeList :unextractable)
(rule ((TypeListRemoveAt (TNil) _idx))
      ((panic "Index out of bounds for TypeListRemoveAt.")) :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) 0)
         xs
         :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) idx)
         (TCons x (TypeListRemoveAt xs (- idx 1)))
         :when ((> idx 0))
         :ruleset type-helpers)

;; Compute the tree size of program, not dag size
(function Expr-size (Expr) i64 :merge (min old new) )
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(rule ((= expr (Function name tyin tyout out)) 
       (= sum (Expr-size out))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty assum))) 
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Top op x y z))
       (= sum (+ (Expr-size z) (+ (Expr-size y) (Expr-size x)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Bop op x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i)) 
       (= sum (Expr-size tup))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred inputs branches)) 
       (= sum  (+ (Expr-size inputs) (+ (ListExpr-size branches) (Expr-size pred)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred inputs then else)) 
       (= sum (+ (Expr-size inputs) (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output)) 
       (= sum (+ (Expr-size pred-and-output) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty assum))) 
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg)) 
       (= sum (Expr-size arg))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty assum)) ((set (Expr-size (Empty ty assum)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl)) 
       (= sum (+ (ListExpr-size tl) (Expr-size hd)))) 
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil)) 
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc id e state ty)) ;; do state edge's expr should be counted?
        (= sum (Expr-size e))) 
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

;; Like Subst but for dropping inputs to a region
;; See subst.egg for more implementation documentation

(ruleset drop)
(ruleset apply-drop-unions)
(ruleset cleanup-drop)

;; (DropAt ctx idx in) removes all references to `(Get (Arg ...) idx)` in `in`.
;; It also replaces the leaf contexts with `ctx` and fixes up argument types,
;; as well as updating `(Get (Arg ...) j)` to `(Get (Arg ...) (- j 1))` for j > idx.
(constructor DropAt (Assumption i64 Expr) Expr :unextractable)
(constructor DelayedDropUnion (Expr Expr) Expr :unextractable)

;; Helper that precomputes the arg type that we need
(constructor DropAtInternal (Type Assumption i64 Expr) Expr :unextractable)
(rule ((= lhs (DropAt ctx idx in))
       (HasArgType in (TupleT oldty)))

      ((let newty (TupleT (TypeListRemoveAt oldty idx)))
       (union lhs (DropAtInternal newty ctx idx in)))
      :ruleset drop)

;; Leaves
(rule ((= lhs (DropAtInternal newty newctx idx (Const c oldty oldctx))))
      ((DelayedDropUnion lhs (Const c newty newctx)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Empty oldty oldctx))))
      ((DelayedDropUnion lhs (Empty newty newctx)))
      :ruleset drop)
; get stuck on purpose if `i = idx` or if we find a bare `Arg`
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (< i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) i)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (> i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) (- i 1))))
      :ruleset drop)

;; Operators
(rule ((= lhs (DropAtInternal newty newctx idx (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedDropUnion lhs (Top op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            (DropAtInternal newty newctx idx c3))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedDropUnion lhs (Bop op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedDropUnion lhs (Uop op
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; this is okay because we get stuck at `Arg`s
(rule ((= lhs (DropAtInternal newty newctx idx (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedDropUnion lhs (Get
            (DropAtInternal newty newctx idx c1)
            index)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedDropUnion lhs (Alloc id
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            ty)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedDropUnion lhs (Call name
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; Tuple operators
(rule ((= lhs (DropAtInternal newty newctx idx (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedDropUnion lhs (Single
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedDropUnion lhs (Concat
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

;; Control flow
(rule ((= lhs (DropAtInternal newty newctx idx (Switch pred inputs c1)))
       (ExprIsResolved (Switch pred inputs c1)))
      ((DelayedDropUnion lhs (Switch
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (If pred inputs c1 c2)))
       (ExprIsResolved (If pred inputs c1 c2)))
      ((DelayedDropUnion lhs (If
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1
            c2)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedDropUnion lhs (DoWhile
            (DropAtInternal newty newctx idx in)
            out)))
      :ruleset drop)

(rewrite (DropAtInternal newty newctx idx (Function name inty outty body))
         (Function name inty outty (DropAtInternal newty newctx idx body))
         :when ((ExprIsResolved body))
         :ruleset drop)



;; ########################### Apply drop unions

(rule ((DelayedDropUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-drop-unions)

;; ########################### Cleanup Dropat, DropAtInternal and DelayedDropUnion

(rule ((ExprIsResolved (DropAt newctx idx in)))
      ((subsume (DropAt newctx idx in)))
      :ruleset cleanup-drop)

(rule ((ExprIsResolved (DropAtInternal newty newctx idx in)))
      ((subsume (DropAtInternal newty newctx idx in)))
      :ruleset cleanup-drop)

(rule ((DelayedDropUnion lhs rhs))
      ((subsume (DelayedDropUnion lhs rhs)))
      :ruleset cleanup-drop)

(ruleset interval-analysis)
(ruleset interval-rewrite)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (Dead) ;; a bound on dead code, so any value can be chosen
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :merge (bound-max old new))
(function hi-bound (Expr) Bound :merge (bound-min old new))

; if lo > hi, we have proven that this code is dead (as long as all our rules are sound)
; In this case, interval analysis might start going crazy and fail to saturate
; So we immediately set the bounds to (Dead)
(rule (
         (= (IntB lo) (lo-bound expr))
         (= (IntB hi) (hi-bound expr))
         (> lo hi)
       ) 
       ((set (lo-bound expr) (Dead))
        (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)
(rule (
      (= (BoolB true) (lo-bound expr))
      (= (BoolB false) (hi-bound expr))
      ) 
      ((set (lo-bound expr) (Dead))
       (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)
(rewrite (bound-max (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-max anything (Dead))
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min anything (Dead))
         (Dead)
         :ruleset interval-analysis)

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (lo-bound lhs) (IntB (+ la lb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (IntB (+ ha hb))))
      :ruleset interval-analysis)

; - a b interval is (- la hb) (- ha lb)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (lo-bound lhs) (IntB (- la hb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (hi-bound lhs) (IntB (- ha lb))))
      :ruleset interval-analysis)

; Multiplication for two constants
; TODO: Make fancier interval analysis
(rule (
       (= lhs (Bop (Mul) a b))
       (= (IntB x) (lo-bound a))
       (= (IntB x) (hi-bound a))
       (= (IntB y) (lo-bound b))
       (= (IntB y) (hi-bound b))
      )
      (
       (set (lo-bound lhs) (IntB (* x y)))
       (set (hi-bound lhs) (IntB (* x y)))
      )
      :ruleset interval-analysis)

; negative * negative is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (< hi-x 0)
        (< hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; negative * positive is negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (< hi-x 0) ; x < 0 (x is negative)
        (> lo-y 0) ; y > 0 (y is positive)
      )
      ((set (hi-bound lhs) (IntB -1)))
      :ruleset interval-analysis)

; positive * positive is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (> lo-x 0)
        (> lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; non-positive * non-positive is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (<= hi-x 0)
        (<= hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-positive * non-negative is non-positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (<= hi-x 0) ; x <= 0 (x is non-positive)
        (>= lo-y 0) ; y >= 0 (y is non-negative)
      )
      ((set (hi-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-negative * non-negative is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (>= lo-x 0)
        (>= lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      (
       (set (lo-bound lhs) (BoolB (bool-< ha lb)))
      )
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (BoolB (bool-< la hb))))
      :ruleset interval-analysis)

; Abs
; abs(x) = x if x >= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB lx) (lo-bound x))
        (>= lx 0)
      )
      ((union lhs x))
      :ruleset interval-rewrite)

; abs(x) = -x if x <= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB hx) (hi-bound x))
        (<= hx 0)
        (HasArgType lhs ty)
        (ContextOf lhs ctx)
      )
      ((union lhs (Bop (Sub) (Const (Int 0) ty ctx) x)))
      :ruleset interval-rewrite)

; =================================
; Conditionals
; =================================
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-rewrite)

; if the predicate is false, merge with else branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB false) (hi-bound cond))
      )
      ((union lhs (Subst if_ctx inputs els)))
      :ruleset interval-rewrite)

; lo-bound of If is the min of the lower bounds
; hi-bound of If is the max of the upper bounds
(rule (
        (= lhs (If cond inputs thn els))
        (= lo-thn (lo-bound thn))
        (= lo-els (lo-bound els))
      )
      ((set (lo-bound lhs) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound thn))
       (= hi-els (hi-bound els))
      )
      ((set (hi-bound lhs) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; If the If takes a tuple
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was true, so we know expr is at most (hi-bound value) - 1
      ((set (hi-bound (Get ctx i)) (IntB (- v 1))))
      :ruleset interval-analysis)
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was false, so we know expr is at least (lo-bound value)
      ((set (lo-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was true, so we know expr is at least (lo-bound value) + 1
      ((set (lo-bound (Get ctx i)) (IntB (+ v 1)))) 
      :ruleset interval-analysis)
(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was false, so we know expr is at most (hi-bound value)
      ((set (hi-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)

; (if (a == b) thn els)
; in the thn branch, we know that a has the same bounds as b
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx  (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB lo) (lo-bound val))
      )
      ((set (lo-bound (Get ctx i)) (IntB lo)))
      :ruleset interval-analysis)
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB hi) (hi-bound val))
      )
      ((set (hi-bound (Get ctx i)) (IntB hi)))
      :ruleset interval-analysis)


(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)


(ruleset switch_rewrite)
(ruleset always-switch-rewrite)

; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)

; if a < b then b else a ~~> (max a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then b else a
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) j))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) i))
      )
      ((union (Get if_e k) (Bop (Smax) a b)))
      :ruleset switch_rewrite) 

; if pred then a else b ~~> (select pred a b)
; where a and b are inputs to the region
(rule (
       (= if_e (If pred inputs thn els))
       (= a (Get inputs i))
       (= b (Get inputs j))

       ; if pred then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))

       ; If i = j, then the arg is just passed through the if, and we
       ; don't need a select. This will get handled by the passthrough rules.
       (!= i j)
       )
       (
       (union (Get if_e k) (Top (Select) pred a b))
       )
       :ruleset switch_rewrite)

(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)
       (= (Get thn i) (Const x _ty (InIf true pred inputs)))
       (= (Get els i) (Const y _ty (InIf false pred inputs)))
      )
      ((union (Get if_e i) (Top (Select) pred (Const x ty ctx) (Const y ty ctx))))
      :ruleset switch_rewrite)

; if pred then A else Const -> select pred A Const
; where A is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       ; input to the if
       (= a (Get inputs i))
       (= (Get thn k) (Get (Arg _ty (InIf true pred inputs)) i))

       (= els_out (Get els k))
       (= (IntB y) (lo-bound els_out))
       (= (IntB y) (hi-bound els_out))
       )
       (
       (union (Get if_e k) (Top (Select) pred a (Const (Int y) ty ctx)))
       )
       :ruleset switch_rewrite
)

; if pred then Const else B -> select pred Const B
; where B is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       (= thn_out (Get thn k))
       (= (IntB y) (lo-bound thn_out))
       (= (IntB y) (hi-bound thn_out))

       ; input to the if
       (= b (Get inputs i))
       (= (Get els k) (Get (Arg _ty (InIf false pred inputs)) i))
      )
      (
       (union (Get if_e k) (Top (Select) pred (Const (Int y) ty ctx) b))
      )
      :ruleset switch_rewrite
)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf true  a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let inner_X (AddContext (InIf true  inner_pred sub_arg_true) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_true) Y))
       (let outer_Y (Subst      (InIf false a          outer_ins) sub_arg_false Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

; if (a or b) X Y ~~> if a X (if b X Y)
(rule ((= lhs (If (Bop (Or) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf false a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let outer_X (Subst      (InIf true  a          outer_ins) sub_arg_true X))
       (let inner_X (AddContext (InIf true  inner_pred sub_arg_false) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_false) Y))

       (let inner (If inner_pred sub_arg_false inner_X inner_Y))
       (union lhs (If a          outer_ins     outer_X inner  )))

       :ruleset switch_rewrite)

(rewrite (If (Const (Bool true)  ty ctx) ins thn els)
         (Subst ctx ins thn)
         :ruleset always-switch-rewrite)

(rewrite (If (Const (Bool false) ty ctx) ins thn els)
         (Subst ctx ins els)
         :ruleset always-switch-rewrite)

(ruleset select_opt)


;; inlined (Get thn i) makes the query faster ):
(rule
       (
        (= if_e (If pred inputs thn els))

        (ExprIsPure (Get thn i))
        (ExprIsPure (Get els i))
        
        (> 10 (Expr-size (Get thn i))) ; TODO: Tune these size limits
        (> 10 (Expr-size (Get els i)))
        (= (TCPair t1 c1) (ExtractedExpr (Get thn i)))
        (= (TCPair t2 c2) (ExtractedExpr (Get els i)))

        (ContextOf if_e ctx)
       )
       (
        (union (Get if_e i)
               (Top (Select) pred (TermSubst ctx inputs t1) (TermSubst ctx inputs t2)))
       )
       :ruleset select_opt
)
; Simple rewrites that don't do a ton with control flow.

(ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 0) ty ctx)) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) (Const (Int 1) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 1) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int 0) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Add) e (Const (Int 0) ty ctx) ) e :ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (* i j)) ty ctx) :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (+ i j)) ty ctx) :ruleset peepholes)

(rewrite (Bop (And) (Const (Bool true) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool true) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (And) (Const (Bool false) ty ctx) e) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool false) ty ctx)) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool false) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool false) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool true) ty ctx) e) (Const (Bool true) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool true) ty ctx)) (Const (Bool true) ty ctx) :ruleset peepholes)

(rule (
        (= expr (Bop (Sub) x x))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Const (Int 0) ty ctx)))
      :ruleset peepholes)

; (x - y) + z => x + (z - y)
(rewrite (Bop (Add) (Bop (Sub) x y) z) (Bop (Add) x (Bop (Sub) z y)) :ruleset peepholes)

; (a + b) - c => a + (b - c)
(rewrite (Bop (Sub) (Bop (Add) a b) c) (Bop (Add) a (Bop (Sub) b c)) :ruleset peepholes)

; (a * x) + a => a * (x + 1)
(rule (
        (= expr (Bop (Add) (Bop (Mul) a x) a))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Bop (Mul) a (Bop (Add) x (Const (Int 1) ty ctx)))))
      :ruleset peepholes)

(rewrite (Top (Select) pred x x) x :ruleset peepholes)

; constant fold `(x + const1) + const2` even when x is not constant
(rewrite (Bop (Add) (Bop (Add) x (Const (Int i) ty ctx)) (Const (Int j) ty ctx))
         (Bop (Add) x (Const (Int (+ i j)) ty ctx))
         :ruleset peepholes)

; ptradd(ptradd(p, x), y) => ptradd(p, x + y)
(rewrite (Bop (PtrAdd) (Bop (PtrAdd) p x) y)
         (Bop (PtrAdd) p (Bop (Add) x y))
         :ruleset peepholes)

(datatype IntOrInfinity
    (Infinity)
    (NegInfinity)
    (I i64))

(constructor MaxIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MaxIntOrInfinity (Infinity) _) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity _ (Infinity)) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity (NegInfinity) x) x :ruleset always-run)
(rewrite (MaxIntOrInfinity x (NegInfinity)) x :ruleset always-run)
(rewrite (MaxIntOrInfinity (I x) (I y)) (I (max x y)) :ruleset always-run)

(constructor MinIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MinIntOrInfinity (NegInfinity) _) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity _ (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity (Infinity) x) x :ruleset always-run)
(rewrite (MinIntOrInfinity x (Infinity)) x :ruleset always-run)
(rewrite (MinIntOrInfinity (I x) (I y)) (I (min x y)) :ruleset always-run)

(constructor AddIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (AddIntOrInfinity (Infinity) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (Infinity) (I _)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (I _)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I x) (I y)) (I (+ x y)) :ruleset always-run)

(datatype IntInterval (MkIntInterval IntOrInfinity IntOrInfinity))

(constructor UnionIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (UnionIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MinIntOrInfinity lo1 lo2) (MaxIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor IntersectIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (IntersectIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MaxIntOrInfinity lo1 lo2) (MinIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor AddIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (AddIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (AddIntOrInfinity lo1 lo2)
                        (AddIntOrInfinity hi1 hi2))
         :ruleset always-run)


(datatype List<i64+IntInterval> 
  (Nil-List<i64+IntInterval>)
  (Cons-List<i64+IntInterval> i64 IntInterval List<i64+IntInterval>))

(function Length-List<i64+IntInterval> (List<i64+IntInterval>) i64 :no-merge)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((IsEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(relation IsNonEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((IsNonEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(constructor RevConcat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (RevConcat-List<i64+IntInterval> (Nil-List<i64+IntInterval>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<i64+IntInterval> (Cons-List<i64+IntInterval> hd0 hd1 tl) l)
         (RevConcat-List<i64+IntInterval> tl (Cons-List<i64+IntInterval> hd0 hd1 l))
         :ruleset always-run)

(constructor Rev-List<i64+IntInterval> (List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Rev-List<i64+IntInterval> m)
         (RevConcat-List<i64+IntInterval> m (Nil-List<i64+IntInterval>))
         :ruleset always-run)

(constructor Concat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Concat-List<i64+IntInterval> x y)
         (RevConcat-List<i64+IntInterval> (Rev-List<i64+IntInterval> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<i64+IntInterval> (List<i64+IntInterval>))
(relation SuffixAt-List<i64+IntInterval> (List<i64+IntInterval> i64 List<i64+IntInterval>))
(relation At-List<i64+IntInterval> (List<i64+IntInterval> i64 i64 IntInterval))
(rule ((DemandAt-List<i64+IntInterval> x))
      ((SuffixAt-List<i64+IntInterval> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<i64+IntInterval> x i (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((SuffixAt-List<i64+IntInterval> x (+ i 1) tl)
       (At-List<i64+IntInterval> x i hd0 hd1))
      :ruleset always-run)

(constructor Union-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor UnionHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Union-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (UnionHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; both m1 and m2 empty
  (rewrite (UnionHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)
  ; take from m1 when m2 empty and vice versa
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      res)
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      tl
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      (Nil-List<i64+IntInterval>)
      res)
    (UnionHelper-List<i64+IntInterval>
      tl
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)

  ; when both nonempty and smallest key different, take smaller key
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 l2 (Cons-List<i64+IntInterval> k1 a1 res))))
        :ruleset always-run)
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f
           (UnionHelper-List<i64+IntInterval> l1 tl2 (Cons-List<i64+IntInterval> k2 b1 res))))
        :ruleset always-run)

  ; when shared smallest key, union interval
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 tl2
             (Cons-List<i64+IntInterval> k (UnionIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor Intersect-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor IntersectHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Intersect-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (IntersectHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; m1 or m2 empty
  (rewrite (IntersectHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) m2 res)
           res
           :ruleset always-run)
  (rewrite (IntersectHelper-List<i64+IntInterval> m1 (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)

  ; when both nonempty and smallest key different, drop smaller key
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)

(datatype MyBool (MyTrue) (MyFalse))

(constructor IntIntervalValid (IntInterval) MyBool)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyTrue)
         :when ((<= lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyFalse)
         :when ((> lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (NegInfinity) _))
         (MyTrue)
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval _ (Infinity)))
         (MyTrue)
         :ruleset always-run)

(constructor ConsIfNonEmpty (i64 IntInterval List<i64+IntInterval>)
          List<i64+IntInterval>
          :cost 100)
(rule ((ConsIfNonEmpty k v tl))
      ((IntIntervalValid v))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyTrue) (IntIntervalValid v)))
      ((union f (Cons-List<i64+IntInterval> k v tl)))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyFalse) (IntIntervalValid v)))
      ((union f tl))
      :ruleset always-run)

  ; when shared smallest key, intersect interval
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (IntersectHelper-List<i64+IntInterval> tl1 tl2
             (ConsIfNonEmpty k (IntersectIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor AddIntIntervalToAll (IntInterval List<i64+IntInterval>)
                              List<i64+IntInterval>)
(rewrite (AddIntIntervalToAll _ (Nil-List<i64+IntInterval>))
         (Nil-List<i64+IntInterval>)
         :ruleset always-run)
(rewrite (AddIntIntervalToAll x (Cons-List<i64+IntInterval> allocid offset tl))
         (Cons-List<i64+IntInterval> allocid (AddIntInterval x offset)
           (AddIntIntervalToAll x tl))
         :ruleset always-run)

(datatype PtrPointees
  (PointsTo List<i64+IntInterval>)
  (PointsAnywhere))

(constructor AddIntIntervalToPtrPointees (IntInterval PtrPointees) PtrPointees)
(rewrite (AddIntIntervalToPtrPointees interval (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (AddIntIntervalToPtrPointees interval (PointsTo l))
         (PointsTo (AddIntIntervalToAll interval l))
         :ruleset always-run)

(constructor Union-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Union-PtrPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Union-List<i64+IntInterval> x y))
         :ruleset always-run)
(constructor Intersect-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Intersect-PtrPointees (PointsAnywhere) x)
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees x (PointsAnywhere))
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Intersect-List<i64+IntInterval> x y))
         :ruleset always-run)

(relation PointsNowhere-PtrPointees (PtrPointees))
(rule ((= f (PointsTo x))
       (IsEmpty-List<i64+IntInterval> x))
      ((PointsNowhere-PtrPointees f))
      :ruleset always-run)


(datatype List<PtrPointees> 
  (Nil-List<PtrPointees>)
  (Cons-List<PtrPointees> PtrPointees List<PtrPointees>))

(function Length-List<PtrPointees> (List<PtrPointees>) i64 :no-merge)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((IsEmpty-List<PtrPointees> x))
      :ruleset always-run)

(relation IsNonEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Cons-List<PtrPointees> hd0 tl)))
      ((IsNonEmpty-List<PtrPointees> x))
      :ruleset always-run)

(constructor RevConcat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (RevConcat-List<PtrPointees> (Nil-List<PtrPointees>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<PtrPointees> (Cons-List<PtrPointees> hd0 tl) l)
         (RevConcat-List<PtrPointees> tl (Cons-List<PtrPointees> hd0 l))
         :ruleset always-run)

(constructor Rev-List<PtrPointees> (List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Rev-List<PtrPointees> m)
         (RevConcat-List<PtrPointees> m (Nil-List<PtrPointees>))
         :ruleset always-run)

(constructor Concat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Concat-List<PtrPointees> x y)
         (RevConcat-List<PtrPointees> (Rev-List<PtrPointees> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<PtrPointees> (List<PtrPointees>))
(relation SuffixAt-List<PtrPointees> (List<PtrPointees> i64 List<PtrPointees>))
(relation At-List<PtrPointees> (List<PtrPointees> i64 PtrPointees))
(rule ((DemandAt-List<PtrPointees> x))
      ((SuffixAt-List<PtrPointees> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<PtrPointees> x i (Cons-List<PtrPointees> hd0 tl)))
      ((SuffixAt-List<PtrPointees> x (+ i 1) tl)
       (At-List<PtrPointees> x i hd0))
      :ruleset always-run)

(relation All<PointsNowhere-PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (PointsNowhere-PtrPointees hd0)
       (All<PointsNowhere-PtrPointees> tl))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
        


(constructor Zip<Union-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Union-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Union-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Union-PtrPointees x0 y0)
            (Zip<Union-PtrPointees> tl1 tl2))
         :when ((= (Length-List<PtrPointees> tl1) (Length-List<PtrPointees> tl2)))
         :ruleset always-run)

(constructor Zip<Intersect-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Intersect-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Intersect-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Intersect-PtrPointees x0 y0)
            (Zip<Intersect-PtrPointees> tl1 tl2))
         :ruleset always-run)


(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(constructor ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset memory-helpers)
(constructor ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset memory-helpers)
(relation ExprSet-contains (ExprSet Expr))
(rule ((ES set1) (set-contains set1 x))
      ((ExprSet-contains (ES set1) x))
      :ruleset memory-helpers)
(constructor ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset memory-helpers)
(function ExprSet-length (ExprSet) i64 :no-merge)
(rewrite (ExprSet-length (ES set1)) (set-length set1) :ruleset memory-helpers)

; ============================
; Pointees
; ============================


; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))

(constructor UnwrapPtrPointsTo (Pointees) PtrPointees)
(rewrite (UnwrapPtrPointsTo (PtrPointsTo x))
         x
         :ruleset memory-helpers)
(constructor UnwrapTuplePointsTo (Pointees) List<PtrPointees>)
(rewrite (UnwrapTuplePointsTo (TuplePointsTo x))
         x
         :ruleset memory-helpers)

(relation PointsNowhere (Pointees))
(rule ((= f (PtrPointsTo x))
       (PointsNowhere-PtrPointees x))
      ((PointsNowhere f))
      :ruleset memory-helpers)
(rule ((= f (TuplePointsTo l))
       (All<PointsNowhere-PtrPointees> l))
      ((PointsNowhere f))
      :ruleset memory-helpers)

(constructor UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Union-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (UnionPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Union-PtrPointees> x y))
         :when ((= (Length-List<PtrPointees> x) (Length-List<PtrPointees> y)))
         :ruleset memory-helpers)
(constructor IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Intersect-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (IntersectPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Intersect-PtrPointees> x y))
         :ruleset memory-helpers)

(constructor GetPointees (Pointees i64) Pointees)
(rule ((= f (GetPointees (TuplePointsTo l) i))
       (At-List<PtrPointees> l i x))
      ((union f (PtrPointsTo x)))
      :ruleset memory-helpers)

(constructor PointeesDropFirst (Pointees) Pointees)
(rewrite (PointeesDropFirst (TuplePointsTo (Cons-List<PtrPointees> hd tl)))
         (TuplePointsTo tl)
         :ruleset memory-helpers)

; ============================
; Resolved
; ============================

; Resolved checks if an e-class contains a term containing only constructors and
; primitives; i.e. whether equality is decideable
(relation Resolved-IntOrInfinity (IntOrInfinity))
(rule ((= f (I _)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (Infinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (NegInfinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)

(relation Resolved-IntInterval (IntInterval))
(rule ((= f (MkIntInterval lo hi))
       (Resolved-IntOrInfinity lo)
       (Resolved-IntOrInfinity hi))
      ((Resolved-IntInterval f))
      :ruleset memory-helpers)

(relation Resolved-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= f (Nil-List<i64+IntInterval>)))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<i64+IntInterval> allocid offsets tl))
       (Resolved-List<i64+IntInterval> tl)
       (Resolved-IntInterval offsets))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)

(relation Resolved-PtrPointees (PtrPointees))
(rule ((= f (PointsAnywhere)))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)
(rule ((= f (PointsTo x))
       (Resolved-List<i64+IntInterval> x))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)

(relation Resolved-List<PtrPointees> (List<PtrPointees>))
(rule ((= f (Nil-List<PtrPointees>)))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<PtrPointees> hd tl))
       (Resolved-List<PtrPointees> tl)
       (Resolved-PtrPointees hd))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)

(relation Resolved-Pointees (Pointees))
(rule ((= f (TuplePointsTo x))
       (Resolved-List<PtrPointees> x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)
(rule ((= f (PtrPointsTo x))
       (Resolved-PtrPointees x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)


;;;;;

(constructor BaseTypeToPtrPointees (BaseType) PtrPointees :cost 100)
(rewrite (BaseTypeToPtrPointees (PointerT _))
         (PointsAnywhere)
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (IntT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (StateT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (BoolT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)

(constructor TypeListToList<PtrPointees> (TypeList) List<PtrPointees> :cost 1000)
(rewrite (TypeListToList<PtrPointees> (TNil))
         (Nil-List<PtrPointees>)
         :ruleset memory-helpers)
(rewrite (TypeListToList<PtrPointees> (TCons hd tl))
         (Cons-List<PtrPointees>
            (BaseTypeToPtrPointees hd)
            (TypeListToList<PtrPointees> tl))
         :ruleset memory-helpers)

(constructor TypeToPointees (Type) Pointees :cost 1000)
(rewrite (TypeToPointees (TupleT tylist))
         (TuplePointsTo (TypeListToList<PtrPointees> tylist))
         :ruleset memory-helpers)
(rewrite (TypeToPointees (Base basety))
         (PtrPointsTo (BaseTypeToPtrPointees basety))
         :ruleset memory-helpers)

; ============================
; Update PointerishType
; ============================

(relation PointerishType (Type))
(relation PointerishTypeList (TypeList))

(rule ((= f (Base (PointerT ty))))
      ((PointerishType f))
      :ruleset always-run)

(rule ((= f (TCons (PointerT ty) tl)))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TCons hd tl))
       (PointerishTypeList tl))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TupleT l))
       (PointerishTypeList l))
      ((PointerishType f))
      :ruleset always-run)

; ============================
; Update PointsToCells
; ============================

;                             arg pointees  result pointees
(constructor PointsToCells (Expr Pointees)     Pointees :unextractable) 

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (TypeToPointees in-ty)))
      :ruleset memory-helpers)

; Demand PointsToCells along state edge and pointer-typed values
(rule ((PointsToCells (Bop (Print) e state) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Top (Write) ptr val state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Alloc id sz state ty) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Free) ptr state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Get x i) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Concat x y) ap))
      ((PointsToCells x ap)
       (PointsToCells y ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Single x) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)

; Compute and propagate PointsToCells
(rewrite (PointsToCells concat-x-y aps)
         (TuplePointsTo (Concat-List<PtrPointees>
           (UnwrapTuplePointsTo (PointsToCells x aps))
           (UnwrapTuplePointsTo (PointsToCells y aps))))
         :when ((= concat-x-y (Concat x y))
                (HasType concat-x-y ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells get-x-i aps)
         (GetPointees (PointsToCells x aps) i)
         :when ((= get-x-i (Get x i))
                (HasType get-x-i ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Single x) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (UnwrapPtrPointsTo (PointsToCells x aps))
             (Nil-List<PtrPointees>)))
         :when ((HasType (Single x) ty) (PointerishType ty))
         :ruleset memory-helpers) 

(rewrite (PointsToCells (Arg ty_ ctx) aps)
         aps
         :when ((HasType (Arg ty_ ctx) ty) (PointerishType ty))
         :ruleset memory-helpers)

; Allow non-pointer types to resolve
(rule ((PointsToCells x aps)
       (HasType x ty))
      ((TypeToPointees ty))
      :ruleset memory-helpers)
(rule ((= f (PointsToCells x aps))
       (HasType x ty)
       (= pointees (TypeToPointees ty))
       (PointsNowhere pointees))
      ((union f pointees))
      :ruleset memory-helpers)

(rewrite (PointsToCells (Bop (PtrAdd) x e) aps)
         (PtrPointsTo
           (AddIntIntervalToPtrPointees
             (MkIntInterval (I lo) (I hi))
             (UnwrapPtrPointsTo (PointsToCells x aps))))
         :when ((= (IntB lo) (lo-bound e))
                (= (IntB hi) (hi-bound e)))
         :ruleset memory-helpers)

(rewrite (PointsToCells (If c inputs t e) aps)
         (UnionPointees
           (PointsToCells t (PointsToCells inputs aps))
           (PointsToCells e (PointsToCells inputs aps)))
         :when ((HasType (If c inputs t e) ty) (PointerishType ty))
         :ruleset memory)

(rewrite (PointsToCells (Alloc id sz state ty) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (PointsTo
               (Cons-List<i64+IntInterval>
                 id
                 (MkIntInterval (I 0) (I 0))
                 (Nil-List<i64+IntInterval>)))
             (Cons-List<PtrPointees>
               (PointsTo (Nil-List<i64+IntInterval>)) ; state output points to nothing
               (Nil-List<PtrPointees>))))
         :ruleset memory-helpers)

; arg pointees * loop in * loop out * i64 -> result pointees
(constructor PointsToCellsAtIter (Pointees Expr Expr i64) Pointees)

; compute first two
(rule ((= e (DoWhile inputs pred-body))
       (PointsToCells e aps))
      ((set (PointsToCellsAtIter aps inputs pred-body 0)
            (PointsToCells inputs aps))
       (set (PointsToCellsAtIter aps inputs pred-body 1)
            (UnionPointees
              (PointsToCellsAtIter aps inputs pred-body 0)
              (PointeesDropFirst
                (PointsToCells pred-body (PointsToCellsAtIter aps inputs pred-body 0))))))
      :ruleset memory-helpers)

; avoid quadratic query
(function succ (i64) i64 :no-merge)
(rule ((PointsToCellsAtIter aps inputs pred-body i))
      ((set (succ i) (+ i 1)))
      :ruleset memory-helpers)

; Note that this rule is bounded by ruleset memory
(rule ((= pointees0 (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees1 (PointsToCellsAtIter aps inputs pred-body (succ i)))
       (Resolved-Pointees pointees0)
       (Resolved-Pointees pointees1)
       (!= pointees0 pointees1))
      ((set (PointsToCellsAtIter aps inputs pred-body (+ i 2))
            (UnionPointees
              pointees1
              (PointeesDropFirst
                (PointsToCells pred-body pointees1)))))
      :ruleset memory)

(rule ((= pointees (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees (PointsToCellsAtIter aps inputs pred-body (succ i))))
      ((set (PointsToCells (DoWhile inputs pred-body) aps)
            pointees))
      :ruleset memory)

(rule ((PtrPointsTo (PointsTo l)))
      ((DemandAt-List<i64+IntInterval> l))
      :ruleset memory-helpers)
(rule ((TuplePointsTo l))
      ((DemandAt-List<PtrPointees> l))
      :ruleset memory-helpers)

; ============================
; Update DontAlias
; ============================

(relation DemandDontAlias (Expr Expr Pointees))
;                    pointer, pointer, arg pointees
(relation DontAlias (Expr Expr Pointees))


(rule ((DemandDontAlias ptr1 ptr2 arg-pointees)
       (BodyContainsExpr body ptr1)
       (BodyContainsExpr body ptr2)
       (HasType ptr1 (Base (PointerT ty)))
       (HasType ptr2 (Base (PointerT ty)))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset memory-helpers)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((DontAlias ptr1 ptr2 arg-pointees))
      :ruleset memory-helpers)

; ============================
; Update PointsToExpr
; ============================

;                       program point, pointer
(constructor PointsToExpr (Expr           Expr) Expr :unextractable)

; After a load, the ptr points to the loaded value
(rule ((= f (Bop (Load) ptr state)))
      ((set (PointsToExpr (Get f 1) ptr) (Get f 0)))
      :ruleset memory-helpers)

; If we load and we already know what the pointer points to
; TODO this rule breaks the weakly linear invariant
; when a previous load may not be on the path
;(rule ((= e (Bop (Load) addr state))
;       (= v (PointsToExpr state addr)))
;      ((union (Get e 0) v)
;       (union (Get e 1) state))
;       :ruleset memory-helpers)

; Loads and prints don't affect what what pointers already point to
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Load) any-addr state)))
      ((let new-state (Get e 1))
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Print) any-val state)))
      ((let new-state e)
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)

; Writes don't affect what a pointer points to if it writes to another pointer
; guaranteed to not alias.
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr)))
      ((DemandDontAlias addr otheraddr (TypeToPointees argty)))
      :ruleset memory-helpers)
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr))
       (DontAlias addr otheraddr (TypeToPointees argty)))
      ((set (PointsToExpr e otheraddr) otherdata))
      :ruleset memory-helpers)

; For a write, mark the given expression as containing `data`.
(rule ((= e (Top (Write) addr data state)))
      ((union (PointsToExpr e addr) data))
      :ruleset memory-helpers)

; ============================
; Update CellHasValues (currently unused)
; ============================

; ;                       program point, cell
; (constructor CellHasValues (Expr i64) ExprSet :merge (ExprSet-intersect old new))

; ; At the time of an alloc, a cell doesn't contain any values
; (rule ((= f (Alloc id amt state ty)))
      ; ((set (CellHasValues (Get f 1) id) (ES (set-empty))))
      ; :ruleset memory-helpers)

; ; These two rules find (Write ptr val state) where 
; ; ptr points to cells given no assumptions about where (Arg) points.
; ; TODO: make sensitive to offsets
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty))
      ; ((TypeToPointees argty))
      ; :ruleset memory-helpers)
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty)
       ; (= (PtrPointsTo (PointsTo cells)) (PointsToCells ptr (TypeToPointees argty)))
       ; (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       ; (= vals (CellHasValues state cell)))
      ; ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      ; :ruleset memory-helpers)


(ruleset mem-simple)

; ============================
; NoAlias analysis
; ============================

(relation NoAlias (Expr Expr))

(rule ((Bop (PtrAdd) e i)
       (= (lo-bound i) (IntB lo))
       (> lo 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (hi-bound i) (IntB hi))
       (< hi 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((NoAlias x y))
      ((NoAlias y x))
      :ruleset mem-simple)

; ============================
; Memory optimizations
; ============================

(relation DidMemOptimization (String))

; A write then a load to different addresses can be swapped
(rule ((NoAlias write-addr load-addr)
       (= write (Top (Write) write-addr write-val state))
       (= load (Bop (Load) load-addr write)))
      ((let new-load (Bop (Load) load-addr state))
       (union
          (Get load 1)
          (Top (Write) write-addr write-val (Get new-load 1)))
       (union (Get load 0) (Get new-load 0))
       (DidMemOptimization "commute write then load")
      )
      :ruleset mem-simple)

; A load then a write to different addresses can be swapped
; Actually, does this break WeaklyLinear if the stored value depends on the
; loaded value? Commenting this out for now.
; (rule ((NoAlias load-addr write-addr)
;        (= load (Bop (Load) load-addr state))
;        (= write (Top (Write) write-addr write-val (Get load 1))))
;       ((let new-write (Top (Write) write-addr write-val state))
;        (let new-load (Bop (Load) load-addr new-write))
;        (union write (Get new-load 1))
;        (union (Get load 0) (Get new-load 0))
;        (DidMemOptimization "commute load then write")
;        )
;       :ruleset mem-simple)

; Two loads to the same address can be compressed
(rule ((= first-load (Bop (Load) addr state))
       (= second-load (Bop (Load) addr first-load)))
      ((union (Get first-load 0) (Get second-load 0))
       (union (Get first-load 1) (Get second-load 1))
       (DidMemOptimization "duplicate load")
       )
      :ruleset mem-simple)

; A write and a load to the same address can be forwarded
(rule ((= write (Top (Write) addr write-val state))
       (= load (Bop (Load) addr write)))
      ((union (Get load 0) write-val)
       (union (Get load 1) write)
       (DidMemOptimization "store forward")
       )
      :ruleset mem-simple)

; Two writes of the same value to the same address can be compressed
(rule ((= first-write (Top (Write) addr write-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union first-write second-write)
       (DidMemOptimization "duplicate write"))
      :ruleset mem-simple)

; A write shadows a previous write to the same address
(rule ((= first-write (Top (Write) addr shadowed-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union second-write (Top (Write) addr write-val state))
       (DidMemOptimization "shadowed write"))
      :ruleset mem-simple)

; A load doesn't change the state
; TODO: why does this break weaklylinear?
; (rule ((= load (Bop (Load) addr state)))
;       ((union (Get load 1) state))
;       :ruleset mem-simple)

; (rule ((DidMemOptimization _))
;       ((panic "DidMemOptimization"))
;       :ruleset mem-simple)

;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)


(function hoisted-loop (Expr Expr) bool :merge (or old new) )
(rule ((= loop (DoWhile in pred_out)))
      ((set (hoisted-loop in pred_out) false)) :ruleset always-run)

(constructor InExtendedLoop (Expr Expr Expr) Assumption)

;; mock function
(ruleset loop-inv-motion)

(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in pred_out))
       ;; the outter assumption of the loop 
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= false (hoisted-loop in pred_out))
       (= len (tuple-length in)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))

       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (InExtendedLoop in pred_out new_input))
       (let new_out_branch (Get (Arg new_input_type assum) len))

       ;; this two subst only change arg to arg with new type
       (let substed_pred_out
         (Subst assum
               (SubTuple (Arg new_input_type assum) 0 len) pred_out))
       (let inv_in_new_loop
            (Subst assum (SubTuple (Arg new_input_type assum) 0 len) inv))
       (let new_pred_out (Concat substed_pred_out (Single new_out_branch)))
       
       (let new_loop (DoWhile new_input new_pred_out))
       (union assum (InLoop new_input new_pred_out))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in pred_out)) 
       ;; don't hoist same loop again
       (set (hoisted-loop in pred_out) true)
      )
       :ruleset loop-inv-motion)


(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Const _n _ty _ctx)))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get (Arg ty ctx) i)) 
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out (+ i 1)))) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Function _name _tyin _tyout _out))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Top _op _x _y _z))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) (= true (is-inv-Expr loop _z)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Bop _op _x _y)) (BinaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Uop _op _x)) (UnaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get _tup _i))  
       (= true (is-inv-Expr loop _tup)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Concat _x _y))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Single _x))  
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Switch _pred _inputs _branches))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _inputs)) (= true (is-inv-ListExpr loop _branches)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (If _pred _input _then _else))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _input)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (DoWhile _in _pred-and-output))  
       (= true (is-inv-Expr loop _in)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Call _func _arg))  
       (= true (is-inv-Expr loop _arg)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Empty _ty _ctx))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _z)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Uop _op _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Single _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _inputs)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _input)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (DoWhile _in _pred-and-output)) 
       (= expr1 _in)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Call _func _arg)) 
       (= expr1 _arg)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _e)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _state)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty ctx)
  (Concat (Single (Const (Bool false) ty ctx2))
    (Single (Const constant ty ctx2))))
 (Single (Const constant ty ctx))
 :ruleset loop-simplify)
;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)

;;                      inputs, outputs -> number of iterations
;; The minimum possible guess is 1 because of do-while loops
;; TODO: dead loop deletion can turn loops with a false condition to a body
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset loop-iters-analysis)

;; For a loop that is false, its num iters is 1
(rule 
  ((= loop (DoWhile inputs outputs))
   (= (Const (Bool false) ty ctx) (Get outputs 0)))
  ((set (LoopNumItersGuess inputs outputs) 1))
:ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated before checking pred
;; TODO: we could make it work for decrementing loops
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by some constant each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while next_counter less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (/ (- end_constant start_const) increment))
  )
  :ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated after checking pred
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   (= body-arg (Get (Arg _ty _ctx) counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by a constant each loop
   (= next_counter (Bop (Add) body-arg
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while this counter less than end_constant
   (= pred (Bop (LessThan) body-arg
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (+ (/ (- end_constant start_const) increment) 1))
  )
  :ruleset loop-iters-analysis)

;; loop peeling rule
;; Only peel loops that we know iterate < 3 times
(constructor LoopPeeledPlaceholder (Expr) Assumption :unextractable)
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs))
  (< old_cost 3)
  )
 (
  (let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))

  (let new-loop-arg
    (Arg inputs-ty then-ctx))
  (let new-loop-body
    (Subst (LoopPeeledPlaceholder lhs) new-loop-arg outputs))
  (union (InLoop new-loop-arg new-loop-body) (LoopPeeledPlaceholder lhs))

  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
      executed-once-body ;; inputs are the body executed once
      (DoWhile new-loop-arg new-loop-body)
      (Arg inputs-ty else-ctx)))

  (set (LoopNumItersGuess new-loop-arg new-loop-body) (- old_cost 1))
  )
 :ruleset loop-peel)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst (TmpCtx) one-iter
          (Subst (TmpCtx) one-iter
            (Subst (TmpCtx) one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union (TmpCtx) actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
    (delete (TmpCtx))
  )
  :ruleset loop-unroll)



(ruleset swap-if)

;; swaps the order of the then and else branches
;; in an if using Not

(rule
  ((= lhs (If pred inputs then else)))
  (
    (union lhs (If (Uop (Not) pred) inputs else then))
  )
  :ruleset swap-if)


;; for if statements with two outputs, swaps the order
;; of the outputs
(rule
  ((= lhs (If pred inputs then else))
   (= (tuple-length then) 2)
   (= (tuple-length else) 2))
  (
    (union
      (Concat (Single (Get lhs 1)) (Single (Get lhs 0)))
      (If pred inputs
          (Concat (Single (Get then 1)) (Single (Get then 0)))
          (Concat (Single (Get else 1)) (Single (Get else 0)))))
  )
  :ruleset swap-if)
;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;      } while (start[0]);
;;    }
;;    ret base_case(start);
;; }
;; for example, printBinary sums the results of recursive calls
(rule
  ((Function name in out body)
   (= body (If pred always-runs (Call name rec_case) base-case))
   (HasType always-runs start-ty)
   (HasType body func-ty))
  ((let loop-inputs (Arg start-ty (InIf true pred always-runs)))
   (let loop-outputs
     (Concat
         (Single (Subst (TmpCtx) rec_case pred))
         (Subst (TmpCtx) rec_case always-runs)))
   (union (TmpCtx) (InLoop loop-inputs loop-outputs))
   (delete (TmpCtx))

   (let loop
     (DoWhile loop-inputs loop-outputs))
    
    
  ;; initial start value
   (let outer-if
     (If pred always-runs
         loop
         (Arg start-ty (InIf false pred always-runs))))
   (union body (Subst (InFunc name) outer-if base-case)))
  :ruleset rec-to-loop)


;; Stores information about how to use a binary
;; operator to accumulate values
;; (bop start-val base-case-op)
(relation Accum-Bop (BinaryOp i64 BinaryOp))

;; addition is easy, it starts at 0 and adds the result of the recursive call
(Accum-Bop (Add) 0 (Add))

;; subtraction starts at zero, but adds the base case at the end
(Accum-Bop (Sub) 0 (Add))

;; multiplication starts at 1, and multiplies the result of the recursive call
(Accum-Bop (Mul) 1 (Mul))

;; It seems like integers have these properties based on: https://stackoverflow.com/questions/69480173/which-arithmetic-properties-do-twos-complement-integers-have


;; same as above rule, but with an accumulator
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start)) + f(start);
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    let acc = 0;
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;         acc = acc + extra(start);
;;      } while (start[0]);
;;    }
;;    ret base_case(start) + acc;
;; }
(rule
  ((Function name in out body)
   (= body (If pred always-runs then-case base-case))
   (= call (Call name rec-case))
   (= then-case
      (Concat (Single (Bop acc-op (Get call 0) extra))
              (Single (Get call 1))))
   (Accum-Bop acc-op initial-int base-case-op)
   (HasType always-runs start-ty)
   (= always-runs-len (tuple-length always-runs))
   (= start-ty (TupleT start-ty-list))
   (HasType body func-ty))
  ((let loop-ty
     (TupleT (TLConcat start-ty-list (TCons (IntT) (TNil)))))
   ;; recursive case in the loop
   (let new-rec-case
    (Subst (TmpCtx)
           (SubTuple (Arg loop-ty (TmpCtx)) 0 always-runs-len) rec-case))
   ;; extra computation in the loop
   (let new-extra
    (Subst (TmpCtx)
           (SubTuple (Arg loop-ty (TmpCtx)) 0 always-runs-len) extra))
   ;; acc starts at 0
   (let loop-inputs
     (Concat (Arg start-ty (InIf true pred always-runs)) (Single (Const (Int initial-int) start-ty (InIf true pred always-runs)))))
   (let loop-outputs
     (Concat
         (Single (Subst (TmpCtx) new-rec-case pred))
         (Concat
           (Subst (TmpCtx) new-rec-case always-runs)
           ;; add extra to acc
           (Single (Bop acc-op (Get (Arg loop-ty (TmpCtx)) always-runs-len) new-extra)))))
   ;; loop starts at zero, adds extra each iteration
   (let loop
     (DoWhile loop-inputs loop-outputs))
   ;; union tmpctx
   (union (TmpCtx) (InLoop loop-inputs loop-outputs))
   (delete (TmpCtx))
  
   (let outer-if
     (If pred always-runs
         loop
         (Concat
           (Arg start-ty (InIf false pred always-runs))
           ;; otherwise acc is 0
           (Single (Const (Int 0) start-ty (InIf false pred always-runs))))))
   ;; base case over latest start value
   (let new-base-case
     (Subst (InFunc name) (SubTuple outer-if 0 always-runs-len) base-case))
   ;; add base case to acc
   (let res
     (Concat
      (Single (Bop base-case-op (Get new-base-case 0) (Get outer-if always-runs-len)))
      (Single (Get new-base-case 1))))
   (union body res))
  :ruleset rec-to-loop)

(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union lhs passed-through))
      :ruleset passthrough)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset passthrough)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(ruleset state-edge-passthrough)

(rule ((= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg arg_ty then_ctx) j))
       (= (Get else_ i) (Get (Arg arg_ty else_ctx) j))

       (HasType (Get then_ i) (Base (StateT))))

      ((let lhs (Get outputs i))
       (let new_inputs (TupleRemoveAt inputs j))

       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let old_then (TupleRemoveAt then_ i))
       (let old_else (TupleRemoveAt else_ i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleRemoveAt outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs (Get inputs j))
       ;; Be careful not to subsume the original if statement immediately,
       ;;  since TupleRemoveAt still needs to match on it
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset state-edge-passthrough)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) pred)
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; Pass through inverted if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool false) _ _thenctx))
       (= (Get else_ i) (Const (Bool true) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) (Uop (Not) pred))
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(ruleset loop-strength-reduction)

; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs
;; Get the input and output value of an invariant, or constant int, within the loop
;;             loop in   out
(relation lsr-inv (Expr Expr Expr))

; TODO: there may be a bug with finding the invariant, or it just may not be extracted.
; Can make this work on loop_with_mul_by_inv and a rust test later.
; (rule (
;     (= loop (DoWhile inputs pred-and-body))
;     (= (Get outputs (+ i 1)) (Get (Arg arg-type assm) i)))
;     ((inv loop (Get inputs i) (Get (Arg arg-type assm) i))) :ruleset always-run)
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf inputs loop-input-ctx)
    (ContextOf pred-and-body loop-output-ctx)
    (= constant (Const c out-type loop-output-ctx))
    (HasArgType inputs in-type)
    )
    ((lsr-inv loop (Const c in-type loop-input-ctx) constant)) :ruleset always-run)

(rule 
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))
        (ContextOf pred-and-outputs loop-ctx)

        ; Find loop variable (argument that gets incremented with an invariant)
        (lsr-inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type assm) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (lsr-inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type assm) i)))
        (ContextOf old-mul loop-ctx)

        (= arg-type (TupleT ty-list))
        ; n is index of our new, temporary variable d
        (= n (tuple-length inputs))
    )
    (
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Construct optimized theta
        ; new-inputs already has the correct context
        (let new-inputs (Concat inputs (Single d-init)))

        ; We need to create a new type, with one more input
        (let new-arg-ty (TupleT (TLConcat ty-list (TCons (IntT) (TNil)))))
        (let replace-arg (SubTuple (Arg new-arg-ty (TmpCtx)) 0 n))

        ; Value of d in loop. Add context to addend
        (let d-out (Bop (Add) (Get (Arg new-arg-ty (TmpCtx)) n)
                   (Subst (TmpCtx) replace-arg addend)))

        ; build the old body, making sure to set the correct arg type and context
        (let new-body
          (Concat
            (Subst (TmpCtx) replace-arg pred-and-outputs)
            (Single d-out)))

        (let new-loop (DoWhile new-inputs new-body))

        (let new-c (Subst (TmpCtx) replace-arg c-out))

        ; Now that we have the new loop, union the temporary context with the actual ctx
        (union (TmpCtx) (InLoop new-inputs new-body))

        ; Substitute d for the *i expression
        (let new-mul
            (Bop (Mul) new-c (Get replace-arg i)))
        (union (Get (Arg new-arg-ty (TmpCtx)) n) new-mul)

        ; Subsume the multiplication in the new loop to prevent
        ; from firing loop strength reduction again on the new loop
        ; Workaround of egglog issue: https://github.com/egraphs-good/egglog/issues/462
        ; add the expression we are about to subsume
        (let before
          (Bop (Mul) new-c (Get replace-arg i)))
        ; now subsume it
        (subsume
          (Bop (Mul) new-c (Get replace-arg i)))

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
        (delete (TmpCtx))
    )
    :ruleset loop-strength-reduction
)
(relation IVTNewInputsAnalysisDemand (Expr))

(ruleset ivt-analysis)

(sort IVTRes)
;;                              perm passthrough-perm passthrough-type passthrough-type-len
(constructor IVTAnalysisRes (Expr Expr             TypeList         i64) IVTRes)
(constructor IVTMin (IVTRes IVTRes) IVTRes)

(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (<= len1 len2))
      ((union lhs (IVTAnalysisRes _a _b _c len1)))
        :ruleset ivt-analysis)
(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (> len1 len2))
      ((union lhs (IVTAnalysisRes _d _e _f len2)))
        :ruleset ivt-analysis)


;; use an analysis to avoid exploring all combinations of passthrough vs not passed through values. Always prefer not passed through
;;                                  expr1 curr  if  result
(function IVTNewInputsAnalysisImpl (Expr  Expr  Node) IVTRes :merge (IVTMin old new))

;; IVTNewInputsAnalysis computes a permutation perm which corresponds to accessing elements of an if region.
;; It also makes accesses of passthrough arguments access new indices after the length of the if region.
;; For example, if expr1 is: [get(if, 1), get(arg, 1), get(if, 0), get(arg, 3)]
;; It produces a new permutation: [get(arg, 1), get(arg, 2), get(arg, 0), get(arg, 3)]
;; The accesses of the if statement remain unchanged, and the accesses of the passthrough arguments are moved to the end.
;; This new permutation is intended to be used with a substitution argument (Concat if-statement passthrough-args)
;; Also produced is a passthrough-perm, which selects all of the passthrough arguments and puts them in a single tuple
;;                              expr1 if result
(function IVTNewInputsAnalysis (Expr  Node) IVTRes :merge (IVTMin old new))


(rule (
    (DoWhile inpW outW)
) (
    (IVTNewInputsAnalysisDemand outW)
) :ruleset ivt-analysis)

(rule (
    (IVTNewInputsAnalysisDemand loop-body)
    ;; first input is a predicate
    (= loop-body (Concat (Single pred) rest))
    ;; another input is an if statement with shared predicate
    (= if-eclass (If pred inputs thn else))
    (= (Get loop-body i) (Get if-eclass j))
    (!= i 0)
) (
    (let perm (Empty (TmpType) (InFunc "no-ctx")))
    (set
     (IVTNewInputsAnalysisImpl loop-body rest (IfNode if-eclass pred inputs thn else))
     (IVTAnalysisRes perm perm (TNil) 0))
) :ruleset ivt-analysis)

;; recursive case for accessing the if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get if-eclass ith)) rest))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm  pperm passthrough-tys len))
) :ruleset ivt-analysis)

;; recursive case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get (Arg ty ctx) ith)) rest))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)

; base case for accessing if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body (Single last) ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= last (Get if-eclass ith))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm pperm passthrough-tys len))
) :ruleset ivt-analysis)

; base case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Single (Get (Arg ty ctx) ith)))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)


(ruleset loop-inversion)

(rule (
    (= loop (DoWhile inpW outW))
    (= (IVTNewInputsAnalysis outW ifnode) (IVTAnalysisRes perm pperm passthrough-tys _len))
    (= ifnode (IfNode if if-cond if-inputs then else))
    (= if-inputs-len (tuple-length if-inputs))
    (= passthrough-len (TypeList-length passthrough-tys))

    (ContextOf inpW outer-ctx)
    (ContextOf if-inputs if-ctx)
    (HasType if-inputs inputs-ty)
    (= inputs-ty (TupleT inputs-ty-list))
) (
    ;; new peeled condition, checks the if's condition before the first iteration
    (let new-if-cond (Subst outer-ctx inpW if-cond))

    ;; new inputs to the if are 1) the inputs run once unconditionally concatted with
    ;; 2) the passthrough values
    (let new-if-inp
        (Concat (Subst outer-ctx inpW if-inputs)
                (Subst outer-ctx inpW pperm)))
    ;; if contexts
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-arg-ty (TupleT (TLConcat inputs-ty-list passthrough-tys)))
    (let new-loop-arg (Arg new-loop-arg-ty (TmpCtx)))
    (let new-loop-context (TmpCtx))

    ;; body
    ;; loop begins by running the then branch of the if statement, which uses the first if-inputs-length elements of arg
    (let then-arg (SubTuple new-loop-arg 0 if-inputs-len))
    (let new-then-branch
        (Subst new-loop-context then-arg then))
    ;; the inputs are then run on the combination of
    ;; the then branch and the passthrough values
    (let then-branch-and-passthrough
      (Concat new-then-branch (SubTuple new-loop-arg if-inputs-len passthrough-len)))
    ;; permute them to move passthrough and if outputs back
    ;; to where if-inputs and if-cond expect them to be
    (let permuted-then-branch-and-passthrough
      (Subst new-loop-context then-branch-and-passthrough perm))
    ;; substitute into inputs and condi
    (let new-inputs-after-then-branch 
        (Subst new-loop-context permuted-then-branch-and-passthrough
            (Concat (Single if-cond) if-inputs)))
    (let new-loop-outputs
        (Concat new-inputs-after-then-branch
           (SubTuple new-loop-arg if-inputs-len passthrough-len)))

    (let new-loop (DoWhile (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg new-loop-arg-ty new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let final-if-inputs
       (SubTuple new-if 0 if-inputs-len))
    (let else-branch-end
        (Subst outer-ctx final-if-inputs else))
    (let else-branch-end-and-passthrough
        (Concat else-branch-end
               (SubTuple new-if if-inputs-len passthrough-len)))
    (let final-permuted
        (Subst outer-ctx else-branch-end-and-passthrough perm))

    (union final-permuted loop)
    (union new-loop-context (InLoop (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))

    (subsume (DoWhile inpW outW))
    (delete (TmpCtx))
) :ruleset loop-inversion)

(ruleset cicm)
(ruleset cicm-index)

(relation InvCodeMotionCandidate (Expr Expr))

(rule (
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t1 c2) (ExtractedExpr e2))
        (ContextOf e1 (InIf true pred1 orig_ins3))
        (ContextOf e2 (InIf false pred2 orig_ins4))
        (!= e1 e2)
     )
     ((InvCodeMotionCandidate e1 e2))
     :ruleset cicm-index)


(rule (
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (= e1 (Uop o x))
        (HasType e1 (Base ty))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (ContextOf e1 (InIf true pred orig_ins))

        (= e2 (Uop o y))
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)
        (ContextOf e2 (InIf false pred orig_ins))

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Uop o (Subst if_tr st_tr x))
        (Uop o (Subst if_fa st_fa y))
        ; Now subsume:
        (subsume (Uop o (Subst if_tr st_tr x)))
        (subsume (Uop o (Subst if_fa st_fa y)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)

       

(rule (
        (InvCodeMotionCandidate e1 e2)
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (ContextOf e1 (InIf true pred orig_ins))
        (ContextOf e2 (InIf false pred orig_ins))
        (= e1 (Bop o x1 y1))
        
        (= e2 (Bop o x2 y2))
        
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (HasType e1 (Base ty))
        

        
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1))
        (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2))
        ; Now subsume:
        (subsume (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1)))
        (subsume (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)


(ruleset push-in)

; new version of the rule where one side of bop is constant
(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o (Const c ty outer_ctx) x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(c, x) in the new regions
        (union (Get arg_tr i) (Bop o (Const c new_ins_ty if_tr) (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Bop o (Const c new_ins_ty if_fa) (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o x (Const c ty outer_ctx)) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(x, c) in the new regions
        (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Const c new_ins_ty if_tr)))
        (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Const c new_ins_ty if_fa)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Uop o x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Uop(x) in the new regions
        (union (Get arg_tr i) (Uop o (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Uop o (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

; OLD VERSION - Too slow for now
; ; push bop input into region
; (rule (
;         (= if_e (If pred orig_inputs thn els))
;         (ContextOf if_e outer_ctx)
;         (= (Bop o x y) (Get orig_inputs i))
;         (HasArgType thn (TupleT tylist))
;         (HasArgType els (TupleT tylist))
;         (HasType x (Base x_ty))
;         (HasType y (Base y_ty))
;       )
;       (
;         ; New inputs
;         (let new_ins (Concat orig_inputs (Concat (Single x) (Single y))))
;         (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TCons y_ty (TNil))))))

;         ; New contexts
;         (let if_tr (InIf true  pred new_ins))
;         (let if_fa (InIf false pred new_ins))
        
;         ; New args
;         (let arg_tr (Arg new_ins_ty if_tr))
;         (let arg_fa (Arg new_ins_ty if_fa))

;         ; SubTuple
;         (let orig_ins_len (TypeList-length tylist))
;         (let st_tr (SubTuple arg_tr 0 orig_ins_len))
;         (let st_fa (SubTuple arg_fa 0 orig_ins_len))

;         ; New regions
;         (let new_thn (Subst if_tr st_tr thn))
;         (let new_els (Subst if_fa st_fa els))

;         ; Union the original input with Bop(x, y) in the new regions
;         (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Get arg_tr (+ orig_ins_len 1))))
;         (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Get arg_fa (+ orig_ins_len 1))))

;         ; Union the ifs
;         (union if_e (If pred new_ins new_thn new_els))
;       )
;       :ruleset push-in)
;; use these rules to clean up the database, removing helpers
;; this makes the visualization easier to read

(ruleset debug-deletes)

(rule ((HasType a b))
      ((delete (HasType a b)))
      :ruleset debug-deletes)

(rule ((BodyContainsExpr a b))
      ((delete (BodyContainsExpr a b)))
      :ruleset debug-deletes)

(rule ((ExprIsPure e))
      ((delete (ExprIsPure e)))
      :ruleset debug-deletes)

(rule ((HasArgType e ty))
      ((delete (HasArgType e ty)))
      :ruleset debug-deletes)

(rule ((is-inv-Expr e ty))
      ((delete (is-inv-Expr e ty)))
      :ruleset debug-deletes)

(rule ((tuple-length e))
      ((delete (tuple-length e)))
      :ruleset debug-deletes)

(rule ((BinaryOpIsPure e))
      ((delete (BinaryOpIsPure e)))
      :ruleset debug-deletes)

(rule ((ContextOf e a))
      ((delete (ContextOf e a)))
      :ruleset debug-deletes)

(rule ((ExprIsResolved e))
      ((delete (ExprIsResolved e)))
      :ruleset debug-deletes)

(rule ((bop->string a b))
      ((delete (bop->string a b)))
      :ruleset debug-deletes)

(rule ((bpred-of-type a b))
      ((delete (bpred-of-type a b)))
      :ruleset debug-deletes)

(rule ((PureType e))
      ((delete (PureType e)))
      :ruleset debug-deletes)

(rule ((PointsToCells a b))
      ((delete (PointsToCells a b)))
      :ruleset debug-deletes)

(rule ((TuplePointsTo e))
      ((delete (TuplePointsTo e)))
      :ruleset debug-deletes)

(rule ((Resolved-List<PtrPointees> e))
      ((delete (Resolved-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((TypeListToList<PtrPointees> e))
      ((delete (TypeListToList<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<PtrPointees> a b))
      ((delete (Cons-List<PtrPointees> a b)))
      :ruleset debug-deletes)

(rule ((Nil-List<PtrPointees>))
      ((delete (Nil-List<PtrPointees>)))
      :ruleset debug-deletes)

(rule ((Length-List<PtrPointees> e))
      ((delete (Length-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((At-List<PtrPointees> a b c))
      ((delete (At-List<PtrPointees> a b c)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<PtrPointees> a))
      ((delete (IsNonEmpty-List<PtrPointees> a)))
      :ruleset debug-deletes)

(rule ((Resolved-List<i64+IntInterval> e))
      ((delete (Resolved-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<i64+IntInterval> a b c))
      ((delete (Cons-List<i64+IntInterval> a b c)))
      :ruleset debug-deletes)

(rule ((Nil-List<i64+IntInterval>))
      ((delete (Nil-List<i64+IntInterval>)))
      :ruleset debug-deletes)

(rule ((Length-List<i64+IntInterval> e))
      ((delete (Length-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((At-List<i64+IntInterval> a b c d))
      ((delete (At-List<i64+IntInterval> a b c d)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<i64+IntInterval> a))
      ((delete (IsNonEmpty-List<i64+IntInterval> a)))
      :ruleset debug-deletes)

(rule ((TypeList-ith a b))
      ((delete (TypeList-ith a b)))
      :ruleset debug-deletes)

(rule ((InIf a b c))
      ((delete (InIf a b c)))
      :ruleset debug-deletes)
(rule ((InLoop a b))
      ((delete (InLoop a b)))
      :ruleset debug-deletes)
(rule ((InFunc a))
      ((delete (InFunc a)))
      :ruleset debug-deletes)

(rule ((TupleT a))
      ((delete (TupleT a)))
      :ruleset debug-deletes)
(rule ((TCons a b))
      ((delete (TCons a b)))
      :ruleset debug-deletes)
(rule ((TNil))
      ((delete (TNil)))
      :ruleset debug-deletes)
(rule ((Base a))
      ((delete (Base a)))
      :ruleset debug-deletes)
(rule ((IntT))
      ((delete (IntT)))
      :ruleset debug-deletes)

;; Hacker's delight optimizations

(ruleset hacker)

;; A simple analysis to identify loops that run exactly #popcount times

;; IsIsEven e x => e is a boolean expression that checks whether x is an even number
(relation IsIsEven (Expr Expr))

(rule (
    (= two (Const (Int 2) ty ctx))
    (= e (Bop (Eq) x (Bop (Mul) (Bop (Div) x two) two)))
) (
    (IsIsEven e x)
) :ruleset hacker)

;; NTZIterations lp n pos => loop lp runs exactly number_of_trailing_zeros(n) times at index pos
(relation NTZIterations (Expr Expr i64))

(rule (
    ;; Grab the outer if
    (= outerif (If cond inputs evenbr oddbr))
    ;; There exists an argument n
    (= n (Get inputs i))
    ;; The condition is on the parity of n
    (IsIsEven cond n)
    ;; In the even/true branch, there is a loop
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    ;; n is passed into to the loop
    (= (Get lp_inputs j) (Get (Arg _ty1 _ctx1) i))
    ;; the loop continues as long as n / 2 is even
    (= two (Const (Int 2) _ty2 _ctx2))
    (= nd2 (Bop (Div) (Get (Arg _ty3 _ctx3) j) two))
    (IsIsEven (Get lp_pred_outputs 0) nd2)
    ;; n is divided by 2 every loop
    (= nd2 (Get lp_pred_outputs (+ j 1)))
    ;; In the odd/false branch, we look for an n
    (= (Get (Arg _ty4 _ctx4) i) (Get oddbr j))
) (
    (NTZIterations outerif n j)
) :ruleset hacker)

;; Identify and optimize lowbit

(rule (
    (NTZIterations outerif n i)
    (= outerif (If cond inputs evenbr oddbr))
    ;; In the even branch, it returns a value that doubles every iter
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    (= (Const (Int 1) _ty1 _ctx1) (Get lp_inputs j))
    (= two (Const (Int 2) _ty2 _ctx2))
    (= (Bop (Mul) (Get (Arg _ty3 _ctx3) j) two) (Get lp_pred_outputs (+ j 1)))    
    ;; In the odd branch, it returns an 1
    (= (Const (Int 1) _ty0 _ctx0) (Get oddbr j))
) (
    (let lowbitn (Bop (Bitand) n (Uop (Neg) n)))
    (union (Get outerif j) lowbitn)
    (union (Get outerif i) (Bop (Div) n lowbitn))
) :ruleset hacker)

;; Try to do a state-edge-passthrough for loops
;; NLZIterations guarantees termination for non-zero values
;; lowbit(0) is undefined behavior

(constructor DummyLoopContext (Expr Expr Expr) Assumption)

(rule (
    (NTZIterations anyif n i)
    (= anyif (If cond inputs thenbr elsebr))
    (= thenbr (DoWhile lpinputs pred_outputs))
    (= (Get pred_outputs (+ j 1)) (Get (Arg arg_ty then_ctx) j))
    (HasType (Get pred_outputs (+ j 1)) (Base (StateT)))
) (
    (let newlpinputs (TupleRemoveAt lpinputs j))
    (let newpred_outputs (TupleRemoveAt pred_outputs (+ j 1)))
    
    (let newlpctx (DummyLoopContext newlpinputs newpred_outputs pred_outputs))

    (let newbody (DropAt newlpctx j newpred_outputs))

    (union newlpctx (InLoop newlpinputs newbody))

    (let newlp (DoWhile newlpinputs newbody))
    (let oldlp (TupleRemoveAt thenbr j))

    (union newlp oldlp)

    (union (Get thenbr j) (Get lpinputs j))

) :ruleset hacker)
(ruleset interval-analysis)
(ruleset interval-rewrite)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (Dead) ;; a bound on dead code, so any value can be chosen
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :merge (bound-max old new))
(function hi-bound (Expr) Bound :merge (bound-min old new))

; if lo > hi, we have proven that this code is dead (as long as all our rules are sound)
; In this case, interval analysis might start going crazy and fail to saturate
; So we immediately set the bounds to (Dead)
(rule (
         (= (IntB lo) (lo-bound expr))
         (= (IntB hi) (hi-bound expr))
         (> lo hi)
       ) 
       ((set (lo-bound expr) (Dead))
        (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)
(rule (
      (= (BoolB true) (lo-bound expr))
      (= (BoolB false) (hi-bound expr))
      ) 
      ((set (lo-bound expr) (Dead))
       (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)
(rewrite (bound-max (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-max anything (Dead))
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min anything (Dead))
         (Dead)
         :ruleset interval-analysis)

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (lo-bound lhs) (IntB (+ la lb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (IntB (+ ha hb))))
      :ruleset interval-analysis)

; - a b interval is (- la hb) (- ha lb)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (lo-bound lhs) (IntB (- la hb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (hi-bound lhs) (IntB (- ha lb))))
      :ruleset interval-analysis)

; Multiplication for two constants
; TODO: Make fancier interval analysis
(rule (
       (= lhs (Bop (Mul) a b))
       (= (IntB x) (lo-bound a))
       (= (IntB x) (hi-bound a))
       (= (IntB y) (lo-bound b))
       (= (IntB y) (hi-bound b))
      )
      (
       (set (lo-bound lhs) (IntB (* x y)))
       (set (hi-bound lhs) (IntB (* x y)))
      )
      :ruleset interval-analysis)

; negative * negative is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (< hi-x 0)
        (< hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; negative * positive is negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (< hi-x 0) ; x < 0 (x is negative)
        (> lo-y 0) ; y > 0 (y is positive)
      )
      ((set (hi-bound lhs) (IntB -1)))
      :ruleset interval-analysis)

; positive * positive is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (> lo-x 0)
        (> lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; non-positive * non-positive is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (<= hi-x 0)
        (<= hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-positive * non-negative is non-positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (<= hi-x 0) ; x <= 0 (x is non-positive)
        (>= lo-y 0) ; y >= 0 (y is non-negative)
      )
      ((set (hi-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-negative * non-negative is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (>= lo-x 0)
        (>= lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      (
       (set (lo-bound lhs) (BoolB (bool-< ha lb)))
      )
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (BoolB (bool-< la hb))))
      :ruleset interval-analysis)

; Abs
; abs(x) = x if x >= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB lx) (lo-bound x))
        (>= lx 0)
      )
      ((union lhs x))
      :ruleset interval-rewrite)

; abs(x) = -x if x <= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB hx) (hi-bound x))
        (<= hx 0)
        (HasArgType lhs ty)
        (ContextOf lhs ctx)
      )
      ((union lhs (Bop (Sub) (Const (Int 0) ty ctx) x)))
      :ruleset interval-rewrite)

; =================================
; Conditionals
; =================================
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-rewrite)

; if the predicate is false, merge with else branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB false) (hi-bound cond))
      )
      ((union lhs (Subst if_ctx inputs els)))
      :ruleset interval-rewrite)

; lo-bound of If is the min of the lower bounds
; hi-bound of If is the max of the upper bounds
(rule (
        (= lhs (If cond inputs thn els))
        (= lo-thn (lo-bound thn))
        (= lo-els (lo-bound els))
      )
      ((set (lo-bound lhs) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound thn))
       (= hi-els (hi-bound els))
      )
      ((set (hi-bound lhs) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; If the If takes a tuple
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was true, so we know expr is at most (hi-bound value) - 1
      ((set (hi-bound (Get ctx i)) (IntB (- v 1))))
      :ruleset interval-analysis)
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was false, so we know expr is at least (lo-bound value)
      ((set (lo-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was true, so we know expr is at least (lo-bound value) + 1
      ((set (lo-bound (Get ctx i)) (IntB (+ v 1)))) 
      :ruleset interval-analysis)
(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was false, so we know expr is at most (hi-bound value)
      ((set (hi-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)

; (if (a == b) thn els)
; in the thn branch, we know that a has the same bounds as b
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx  (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB lo) (lo-bound val))
      )
      ((set (lo-bound (Get ctx i)) (IntB lo)))
      :ruleset interval-analysis)
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB hi) (hi-bound val))
      )
      ((set (hi-bound (Get ctx i)) (IntB hi)))
      :ruleset interval-analysis)


(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)

(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(constructor TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64 :no-merge)
(constructor TypeList-ith (TypeList i64) BaseType :unextractable)
;; Don't match on TypeList-ith because it is now lazily instantiated!
(rule () ((set (TypeList-length (TNil)) 0)) :ruleset type-helpers)
(rule ((= lst (TCons hd tl))
       (= len (TypeList-length tl)))
      ((set (TypeList-length lst) (+ 1 len))) :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) 0) hd :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) i) (TypeList-ith tl (- i 1)) 
      :when ((> i 0)) 
      :ruleset type-helpers)

(rule ((TypeList-ith list i)
       (= (TypeList-length list) n)
       (>= i n))
      ((panic "TypeList-ith out of bounds")) :ruleset type-helpers)

(relation HasType (Expr Type))


;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      ((extract "Expecting expression")
       (extract e)
       (extract "to have type")
       (extract expected)
       (extract "but got type")
       (extract actual)
       (extract "with message")
       (extract msg)
       (panic "type mismatch- check RUST_LOG=info for expressions that mismatched"))
      :ruleset error-checking)


(rule ((= (Const c1 ty1 ctx1) (Const c2 ty2 ctx2))
       (= ctx1 (InFunc name))
       (!= c1 c2))
      ((panic "Unsoundness detected: const values differ at top level"))
      :ruleset error-checking)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1 ctx) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset error-checking)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset error-checking)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType branch ty)
       (HasType inputs ty2)
       (!= ty ty2))
      ((panic "switch branches then branch has incorrect input type"))
      :ruleset error-checking)
;; demand with one fewer branches
(rule ((= lhs (Switch pred inputs (Cons branch rest))))
      ((Switch pred inputs rest))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType t ty2)
       (!= ty ty2))
      ((panic "if branches then branch has incorrect input type"))
      :ruleset error-checking)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType e ty2)
       (!= ty ty2))
      ((panic "if branches else branch has incorrect input type"))
      :ruleset error-checking)


(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty ctx)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty ctx)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Float b) ty ctx)))
      ((HasType lhs (Base (FloatT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty ctx)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not)"))
      :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
      (HasType e (Base (IntT)))
) (
      (HasType lhs (Base (IntT)))
) :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
) (
      (ExpectType e (Base (IntT)) "(Neg)")
) :ruleset type-analysis)

(rule (
        (= lhs (Uop (Abs) e))
        (HasType e (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Abs) e)))
      ((ExpectType e (Base (IntT)) "(Abs)"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset error-checking)

(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset error-checking)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset error-checking)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Top (Select) pred v1 v2))
      )
      ((ExpectType pred (Base (BoolT)) "(Select)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty)
        (HasType v2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty1)
        (HasType v2 ty2)
        (!= ty1 ty2)
      )
      ((panic "(Select) branches had different types"))
      :ruleset error-checking)


; Binary ops

;; Operators that have type Type -> Type -> Type
;; Note we only do this generic matching for binary
;; operator since there's a lot of them.
;; In the future we can also extend to other constructs.
(relation bop-of-type (BinaryOp Type))
(bop-of-type (Bitand) (Base (IntT)))
(bop-of-type (Add) (Base (IntT)))
(bop-of-type (Sub) (Base (IntT)))
(bop-of-type (Div) (Base (IntT)))
(bop-of-type (Mul) (Base (IntT)))
(bop-of-type (FAdd) (Base (FloatT)))
(bop-of-type (FSub) (Base (FloatT)))
(bop-of-type (FDiv) (Base (FloatT)))
(bop-of-type (FMul) (Base (FloatT)))

(rule (
        (= lhs (Bop op e1 e2))
        (bop-of-type op ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop op e1 e2))
       (bop-of-type op ty)
       (bop->string op op-str))
      (
        (ExpectType e1 ty op-str)
        (ExpectType e2 ty op-str)
      )
      :ruleset type-analysis)  

;; Operators that have type Float -> Float -> Bool
(relation bpred-of-type (BinaryOp Type))
(bpred-of-type (FLessThan) (Base (FloatT)))
(bpred-of-type (FLessEq) (Base (FloatT)))
(bpred-of-type (FGreaterThan) (Base (FloatT)))
(bpred-of-type (FGreaterEq) (Base (FloatT)))
(bpred-of-type (FEq) (Base (FloatT)))
(bpred-of-type (LessThan) (Base (IntT)))
(bpred-of-type (LessEq) (Base (IntT)))
(bpred-of-type (GreaterThan) (Base (IntT)))
(bpred-of-type (GreaterEq) (Base (IntT)))
(bpred-of-type (Eq) (Base (IntT)))
(bpred-of-type (And) (Base (BoolT)))
(bpred-of-type (Or) (Base (BoolT)))

(rule (
        (= lhs (Bop pred e1 e2))
        (bpred-of-type pred ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop pred e1 e2))
       (bpred-of-type pred ty)
       (bop->string pred pred-str))
      (
        (ExpectType e1 ty pred-str)
        (ExpectType e2 ty pred-str)
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base ty)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write)"))
      :ruleset type-analysis)
      
       

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i)))) 
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset error-checking)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset error-checking)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset error-checking)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred inputs then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset error-checking)



(rule ((= lhs (Switch pred inputs branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred inputs (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred inputs (Cons branch rest)))
      ((Switch pred inputs rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred inputs rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred inputs rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset error-checking)

(rule ((Arg ty ctx))
      (
        (HasType (Arg ty ctx) ty)
        (HasArgType (Arg ty ctx) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset error-checking)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; find which types are pure
(relation PureBaseType (BaseType))
(relation PureType (Type))
(relation PureTypeList (TypeList))

(PureBaseType (IntT))
(PureBaseType (BoolT))
(rule ((Base ty)
       (PureBaseType ty))
      ((PureType (Base ty)))
      :ruleset type-analysis)
(rule ((TupleT tylist)
       (PureTypeList tylist))
      ((PureType (TupleT tylist)))
      :ruleset type-analysis)
(rule ((TNil))
      ((PureTypeList (TNil)))
      :ruleset type-analysis)
(rule ((TCons hd tl)
       (PureBaseType hd)
       (PureTypeList tl))
      ((PureTypeList (TCons hd tl)))
      :ruleset type-analysis)
(ruleset cicm)
(ruleset cicm-index)

(relation InvCodeMotionCandidate (Expr Expr))

(rule (
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t1 c2) (ExtractedExpr e2))
        (ContextOf e1 (InIf true pred1 orig_ins3))
        (ContextOf e2 (InIf false pred2 orig_ins4))
        (!= e1 e2)
     )
     ((InvCodeMotionCandidate e1 e2))
     :ruleset cicm-index)


(rule (
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (= e1 (Uop o x))
        (HasType e1 (Base ty))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (ContextOf e1 (InIf true pred orig_ins))

        (= e2 (Uop o y))
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)
        (ContextOf e2 (InIf false pred orig_ins))

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Uop o (Subst if_tr st_tr x))
        (Uop o (Subst if_fa st_fa y))
        ; Now subsume:
        (subsume (Uop o (Subst if_tr st_tr x)))
        (subsume (Uop o (Subst if_fa st_fa y)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)

       

(rule (
        (InvCodeMotionCandidate e1 e2)
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (ContextOf e1 (InIf true pred orig_ins))
        (ContextOf e2 (InIf false pred orig_ins))
        (= e1 (Bop o x1 y1))
        
        (= e2 (Bop o x2 y2))
        
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (HasType e1 (Base ty))
        

        
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1))
        (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2))
        ; Now subsume:
        (subsume (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1)))
        (subsume (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)

;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(ruleset loop-strength-reduction)

; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs
;; Get the input and output value of an invariant, or constant int, within the loop
;;             loop in   out
(relation lsr-inv (Expr Expr Expr))

; TODO: there may be a bug with finding the invariant, or it just may not be extracted.
; Can make this work on loop_with_mul_by_inv and a rust test later.
; (rule (
;     (= loop (DoWhile inputs pred-and-body))
;     (= (Get outputs (+ i 1)) (Get (Arg arg-type assm) i)))
;     ((inv loop (Get inputs i) (Get (Arg arg-type assm) i))) :ruleset always-run)
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf inputs loop-input-ctx)
    (ContextOf pred-and-body loop-output-ctx)
    (= constant (Const c out-type loop-output-ctx))
    (HasArgType inputs in-type)
    )
    ((lsr-inv loop (Const c in-type loop-input-ctx) constant)) :ruleset always-run)

(rule 
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))
        (ContextOf pred-and-outputs loop-ctx)

        ; Find loop variable (argument that gets incremented with an invariant)
        (lsr-inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type assm) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (lsr-inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type assm) i)))
        (ContextOf old-mul loop-ctx)

        (= arg-type (TupleT ty-list))
        ; n is index of our new, temporary variable d
        (= n (tuple-length inputs))
    )
    (
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Construct optimized theta
        ; new-inputs already has the correct context
        (let new-inputs (Concat inputs (Single d-init)))

        ; We need to create a new type, with one more input
        (let new-arg-ty (TupleT (TLConcat ty-list (TCons (IntT) (TNil)))))
        (let replace-arg (SubTuple (Arg new-arg-ty (TmpCtx)) 0 n))

        ; Value of d in loop. Add context to addend
        (let d-out (Bop (Add) (Get (Arg new-arg-ty (TmpCtx)) n)
                   (Subst (TmpCtx) replace-arg addend)))

        ; build the old body, making sure to set the correct arg type and context
        (let new-body
          (Concat
            (Subst (TmpCtx) replace-arg pred-and-outputs)
            (Single d-out)))

        (let new-loop (DoWhile new-inputs new-body))

        (let new-c (Subst (TmpCtx) replace-arg c-out))

        ; Now that we have the new loop, union the temporary context with the actual ctx
        (union (TmpCtx) (InLoop new-inputs new-body))

        ; Substitute d for the *i expression
        (let new-mul
            (Bop (Mul) new-c (Get replace-arg i)))
        (union (Get (Arg new-arg-ty (TmpCtx)) n) new-mul)

        ; Subsume the multiplication in the new loop to prevent
        ; from firing loop strength reduction again on the new loop
        ; Workaround of egglog issue: https://github.com/egraphs-good/egglog/issues/462
        ; add the expression we are about to subsume
        (let before
          (Bop (Mul) new-c (Get replace-arg i)))
        ; now subsume it
        (subsume
          (Bop (Mul) new-c (Get replace-arg i)))

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
        (delete (TmpCtx))
    )
    :ruleset loop-strength-reduction
)(ruleset push-in)

; new version of the rule where one side of bop is constant
(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o (Const c ty outer_ctx) x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(c, x) in the new regions
        (union (Get arg_tr i) (Bop o (Const c new_ins_ty if_tr) (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Bop o (Const c new_ins_ty if_fa) (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o x (Const c ty outer_ctx)) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(x, c) in the new regions
        (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Const c new_ins_ty if_tr)))
        (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Const c new_ins_ty if_fa)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Uop o x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Uop(x) in the new regions
        (union (Get arg_tr i) (Uop o (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Uop o (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

; OLD VERSION - Too slow for now
; ; push bop input into region
; (rule (
;         (= if_e (If pred orig_inputs thn els))
;         (ContextOf if_e outer_ctx)
;         (= (Bop o x y) (Get orig_inputs i))
;         (HasArgType thn (TupleT tylist))
;         (HasArgType els (TupleT tylist))
;         (HasType x (Base x_ty))
;         (HasType y (Base y_ty))
;       )
;       (
;         ; New inputs
;         (let new_ins (Concat orig_inputs (Concat (Single x) (Single y))))
;         (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TCons y_ty (TNil))))))

;         ; New contexts
;         (let if_tr (InIf true  pred new_ins))
;         (let if_fa (InIf false pred new_ins))
        
;         ; New args
;         (let arg_tr (Arg new_ins_ty if_tr))
;         (let arg_fa (Arg new_ins_ty if_fa))

;         ; SubTuple
;         (let orig_ins_len (TypeList-length tylist))
;         (let st_tr (SubTuple arg_tr 0 orig_ins_len))
;         (let st_fa (SubTuple arg_fa 0 orig_ins_len))

;         ; New regions
;         (let new_thn (Subst if_tr st_tr thn))
;         (let new_els (Subst if_fa st_fa els))

;         ; Union the original input with Bop(x, y) in the new regions
;         (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Get arg_tr (+ orig_ins_len 1))))
;         (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Get arg_fa (+ orig_ins_len 1))))

;         ; Union the ifs
;         (union if_e (If pred new_ins new_thn new_els))
;       )
;       :ruleset push-in)(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union lhs passed-through))
      :ruleset passthrough)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset passthrough)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(ruleset state-edge-passthrough)

(rule ((= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg arg_ty then_ctx) j))
       (= (Get else_ i) (Get (Arg arg_ty else_ctx) j))

       (HasType (Get then_ i) (Base (StateT))))

      ((let lhs (Get outputs i))
       (let new_inputs (TupleRemoveAt inputs j))

       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let old_then (TupleRemoveAt then_ i))
       (let old_else (TupleRemoveAt else_ i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleRemoveAt outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs (Get inputs j))
       ;; Be careful not to subsume the original if statement immediately,
       ;;  since TupleRemoveAt still needs to match on it
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset state-edge-passthrough)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) pred)
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; Pass through inverted if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool false) _ _thenctx))
       (= (Get else_ i) (Const (Bool true) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) (Uop (Not) pred))
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)
;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;      } while (start[0]);
;;    }
;;    ret base_case(start);
;; }
;; for example, printBinary sums the results of recursive calls
(rule
  ((Function name in out body)
   (= body (If pred always-runs (Call name rec_case) base-case))
   (HasType always-runs start-ty)
   (HasType body func-ty))
  ((let loop-inputs (Arg start-ty (InIf true pred always-runs)))
   (let loop-outputs
     (Concat
         (Single (Subst (TmpCtx) rec_case pred))
         (Subst (TmpCtx) rec_case always-runs)))
   (union (TmpCtx) (InLoop loop-inputs loop-outputs))
   (delete (TmpCtx))

   (let loop
     (DoWhile loop-inputs loop-outputs))
    
    
  ;; initial start value
   (let outer-if
     (If pred always-runs
         loop
         (Arg start-ty (InIf false pred always-runs))))
   (union body (Subst (InFunc name) outer-if base-case)))
  :ruleset rec-to-loop)


;; Stores information about how to use a binary
;; operator to accumulate values
;; (bop start-val base-case-op)
(relation Accum-Bop (BinaryOp i64 BinaryOp))

;; addition is easy, it starts at 0 and adds the result of the recursive call
(Accum-Bop (Add) 0 (Add))

;; subtraction starts at zero, but adds the base case at the end
(Accum-Bop (Sub) 0 (Add))

;; multiplication starts at 1, and multiplies the result of the recursive call
(Accum-Bop (Mul) 1 (Mul))

;; It seems like integers have these properties based on: https://stackoverflow.com/questions/69480173/which-arithmetic-properties-do-twos-complement-integers-have


;; same as above rule, but with an accumulator
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start)) + f(start);
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    let acc = 0;
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;         acc = acc + extra(start);
;;      } while (start[0]);
;;    }
;;    ret base_case(start) + acc;
;; }
(rule
  ((Function name in out body)
   (= body (If pred always-runs then-case base-case))
   (= call (Call name rec-case))
   (= then-case
      (Concat (Single (Bop acc-op (Get call 0) extra))
              (Single (Get call 1))))
   (Accum-Bop acc-op initial-int base-case-op)
   (HasType always-runs start-ty)
   (= always-runs-len (tuple-length always-runs))
   (= start-ty (TupleT start-ty-list))
   (HasType body func-ty))
  ((let loop-ty
     (TupleT (TLConcat start-ty-list (TCons (IntT) (TNil)))))
   ;; recursive case in the loop
   (let new-rec-case
    (Subst (TmpCtx)
           (SubTuple (Arg loop-ty (TmpCtx)) 0 always-runs-len) rec-case))
   ;; extra computation in the loop
   (let new-extra
    (Subst (TmpCtx)
           (SubTuple (Arg loop-ty (TmpCtx)) 0 always-runs-len) extra))
   ;; acc starts at 0
   (let loop-inputs
     (Concat (Arg start-ty (InIf true pred always-runs)) (Single (Const (Int initial-int) start-ty (InIf true pred always-runs)))))
   (let loop-outputs
     (Concat
         (Single (Subst (TmpCtx) new-rec-case pred))
         (Concat
           (Subst (TmpCtx) new-rec-case always-runs)
           ;; add extra to acc
           (Single (Bop acc-op (Get (Arg loop-ty (TmpCtx)) always-runs-len) new-extra)))))
   ;; loop starts at zero, adds extra each iteration
   (let loop
     (DoWhile loop-inputs loop-outputs))
   ;; union tmpctx
   (union (TmpCtx) (InLoop loop-inputs loop-outputs))
   (delete (TmpCtx))
  
   (let outer-if
     (If pred always-runs
         loop
         (Concat
           (Arg start-ty (InIf false pred always-runs))
           ;; otherwise acc is 0
           (Single (Const (Int 0) start-ty (InIf false pred always-runs))))))
   ;; base case over latest start value
   (let new-base-case
     (Subst (InFunc name) (SubTuple outer-if 0 always-runs-len) base-case))
   ;; add base case to acc
   (let res
     (Concat
      (Single (Bop base-case-op (Get new-base-case 0) (Get outer-if always-runs-len)))
      (Single (Get new-base-case 1))))
   (union body res))
  :ruleset rec-to-loop)

(ruleset mem-simple)

; ============================
; NoAlias analysis
; ============================

(relation NoAlias (Expr Expr))

(rule ((Bop (PtrAdd) e i)
       (= (lo-bound i) (IntB lo))
       (> lo 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (hi-bound i) (IntB hi))
       (< hi 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((NoAlias x y))
      ((NoAlias y x))
      :ruleset mem-simple)

; ============================
; Memory optimizations
; ============================

(relation DidMemOptimization (String))

; A write then a load to different addresses can be swapped
(rule ((NoAlias write-addr load-addr)
       (= write (Top (Write) write-addr write-val state))
       (= load (Bop (Load) load-addr write)))
      ((let new-load (Bop (Load) load-addr state))
       (union
          (Get load 1)
          (Top (Write) write-addr write-val (Get new-load 1)))
       (union (Get load 0) (Get new-load 0))
       (DidMemOptimization "commute write then load")
      )
      :ruleset mem-simple)

; A load then a write to different addresses can be swapped
; Actually, does this break WeaklyLinear if the stored value depends on the
; loaded value? Commenting this out for now.
; (rule ((NoAlias load-addr write-addr)
;        (= load (Bop (Load) load-addr state))
;        (= write (Top (Write) write-addr write-val (Get load 1))))
;       ((let new-write (Top (Write) write-addr write-val state))
;        (let new-load (Bop (Load) load-addr new-write))
;        (union write (Get new-load 1))
;        (union (Get load 0) (Get new-load 0))
;        (DidMemOptimization "commute load then write")
;        )
;       :ruleset mem-simple)

; Two loads to the same address can be compressed
(rule ((= first-load (Bop (Load) addr state))
       (= second-load (Bop (Load) addr first-load)))
      ((union (Get first-load 0) (Get second-load 0))
       (union (Get first-load 1) (Get second-load 1))
       (DidMemOptimization "duplicate load")
       )
      :ruleset mem-simple)

; A write and a load to the same address can be forwarded
(rule ((= write (Top (Write) addr write-val state))
       (= load (Bop (Load) addr write)))
      ((union (Get load 0) write-val)
       (union (Get load 1) write)
       (DidMemOptimization "store forward")
       )
      :ruleset mem-simple)

; Two writes of the same value to the same address can be compressed
(rule ((= first-write (Top (Write) addr write-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union first-write second-write)
       (DidMemOptimization "duplicate write"))
      :ruleset mem-simple)

; A write shadows a previous write to the same address
(rule ((= first-write (Top (Write) addr shadowed-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union second-write (Top (Write) addr write-val state))
       (DidMemOptimization "shadowed write"))
      :ruleset mem-simple)

; A load doesn't change the state
; TODO: why does this break weaklylinear?
; (rule ((= load (Bop (Load) addr state)))
;       ((union (Get load 1) state))
;       :ruleset mem-simple)

; (rule ((DidMemOptimization _))
;       ((panic "DidMemOptimization"))
;       :ruleset mem-simple)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty ctx)
  (Concat (Single (Const (Bool false) ty ctx2))
    (Single (Const constant ty ctx2))))
 (Single (Const constant ty ctx))
 :ruleset loop-simplify)(ruleset switch_rewrite)
(ruleset always-switch-rewrite)

; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)

; if a < b then b else a ~~> (max a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then b else a
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) j))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) i))
      )
      ((union (Get if_e k) (Bop (Smax) a b)))
      :ruleset switch_rewrite) 

; if pred then a else b ~~> (select pred a b)
; where a and b are inputs to the region
(rule (
       (= if_e (If pred inputs thn els))
       (= a (Get inputs i))
       (= b (Get inputs j))

       ; if pred then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))

       ; If i = j, then the arg is just passed through the if, and we
       ; don't need a select. This will get handled by the passthrough rules.
       (!= i j)
       )
       (
       (union (Get if_e k) (Top (Select) pred a b))
       )
       :ruleset switch_rewrite)

(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)
       (= (Get thn i) (Const x _ty (InIf true pred inputs)))
       (= (Get els i) (Const y _ty (InIf false pred inputs)))
      )
      ((union (Get if_e i) (Top (Select) pred (Const x ty ctx) (Const y ty ctx))))
      :ruleset switch_rewrite)

; if pred then A else Const -> select pred A Const
; where A is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       ; input to the if
       (= a (Get inputs i))
       (= (Get thn k) (Get (Arg _ty (InIf true pred inputs)) i))

       (= els_out (Get els k))
       (= (IntB y) (lo-bound els_out))
       (= (IntB y) (hi-bound els_out))
       )
       (
       (union (Get if_e k) (Top (Select) pred a (Const (Int y) ty ctx)))
       )
       :ruleset switch_rewrite
)

; if pred then Const else B -> select pred Const B
; where B is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       (= thn_out (Get thn k))
       (= (IntB y) (lo-bound thn_out))
       (= (IntB y) (hi-bound thn_out))

       ; input to the if
       (= b (Get inputs i))
       (= (Get els k) (Get (Arg _ty (InIf false pred inputs)) i))
      )
      (
       (union (Get if_e k) (Top (Select) pred (Const (Int y) ty ctx) b))
      )
      :ruleset switch_rewrite
)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf true  a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let inner_X (AddContext (InIf true  inner_pred sub_arg_true) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_true) Y))
       (let outer_Y (Subst      (InIf false a          outer_ins) sub_arg_false Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

; if (a or b) X Y ~~> if a X (if b X Y)
(rule ((= lhs (If (Bop (Or) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf false a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let outer_X (Subst      (InIf true  a          outer_ins) sub_arg_true X))
       (let inner_X (AddContext (InIf true  inner_pred sub_arg_false) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_false) Y))

       (let inner (If inner_pred sub_arg_false inner_X inner_Y))
       (union lhs (If a          outer_ins     outer_X inner  )))

       :ruleset switch_rewrite)

(rewrite (If (Const (Bool true)  ty ctx) ins thn els)
         (Subst ctx ins thn)
         :ruleset always-switch-rewrite)

(rewrite (If (Const (Bool false) ty ctx) ins thn els)
         (Subst ctx ins els)
         :ruleset always-switch-rewrite)
(ruleset swap-if)

;; swaps the order of the then and else branches
;; in an if using Not

(rule
  ((= lhs (If pred inputs then else)))
  (
    (union lhs (If (Uop (Not) pred) inputs else then))
  )
  :ruleset swap-if)


;; for if statements with two outputs, swaps the order
;; of the outputs
(rule
  ((= lhs (If pred inputs then else))
   (= (tuple-length then) 2)
   (= (tuple-length else) 2))
  (
    (union
      (Concat (Single (Get lhs 1)) (Single (Get lhs 0)))
      (If pred inputs
          (Concat (Single (Get then 1)) (Single (Get then 0)))
          (Concat (Single (Get else 1)) (Single (Get else 0)))))
  )
  :ruleset swap-if); Simple rewrites that don't do a ton with control flow.

(ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 0) ty ctx)) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) (Const (Int 1) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 1) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int 0) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Add) e (Const (Int 0) ty ctx) ) e :ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (* i j)) ty ctx) :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (+ i j)) ty ctx) :ruleset peepholes)

(rewrite (Bop (And) (Const (Bool true) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool true) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (And) (Const (Bool false) ty ctx) e) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool false) ty ctx)) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool false) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool false) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool true) ty ctx) e) (Const (Bool true) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool true) ty ctx)) (Const (Bool true) ty ctx) :ruleset peepholes)

(rule (
        (= expr (Bop (Sub) x x))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Const (Int 0) ty ctx)))
      :ruleset peepholes)

; (x - y) + z => x + (z - y)
(rewrite (Bop (Add) (Bop (Sub) x y) z) (Bop (Add) x (Bop (Sub) z y)) :ruleset peepholes)

; (a + b) - c => a + (b - c)
(rewrite (Bop (Sub) (Bop (Add) a b) c) (Bop (Add) a (Bop (Sub) b c)) :ruleset peepholes)

; (a * x) + a => a * (x + 1)
(rule (
        (= expr (Bop (Add) (Bop (Mul) a x) a))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Bop (Mul) a (Bop (Add) x (Const (Int 1) ty ctx)))))
      :ruleset peepholes)

(rewrite (Top (Select) pred x x) x :ruleset peepholes)

; constant fold `(x + const1) + const2` even when x is not constant
(rewrite (Bop (Add) (Bop (Add) x (Const (Int i) ty ctx)) (Const (Int j) ty ctx))
         (Bop (Add) x (Const (Int (+ i j)) ty ctx))
         :ruleset peepholes)

; ptradd(ptradd(p, x), y) => ptradd(p, x + y)
(rewrite (Bop (PtrAdd) (Bop (PtrAdd) p x) y)
         (Bop (PtrAdd) p (Bop (Add) x y))
         :ruleset peepholes)(relation ExprIsPure (Expr))
(relation ListExprIsPure (ListExpr))
(relation BinaryOpIsPure (BinaryOp))
(relation UnaryOpIsPure (UnaryOp))
(relation TernaryOpIsPure (TernaryOp))
(TernaryOpIsPure (Select))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (Smax))
(BinaryOpIsPure (Smin))
(BinaryOpIsPure (Shl))
(BinaryOpIsPure (Shr))
(BinaryOpIsPure (FAdd))
(BinaryOpIsPure (FSub))
(BinaryOpIsPure (FMul))
(BinaryOpIsPure (FDiv))
(BinaryOpIsPure (FEq))
(BinaryOpIsPure (FLessThan))
(BinaryOpIsPure (FGreaterThan))
(BinaryOpIsPure (FLessEq))
(BinaryOpIsPure (FGreaterEq))
(BinaryOpIsPure (Fmax))
(BinaryOpIsPure (Fmin))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(BinaryOpIsPure (Bitand))
(UnaryOpIsPure (Not))
(UnaryOpIsPure (Abs))
(UnaryOpIsPure (Neg))

(rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
        ((ExprIsPure (Function _name _tyin _tyout _out)))
        :ruleset always-run)

(rule ((Const _n _ty _ctx))
        ((ExprIsPure (Const _n _ty _ctx)))
        :ruleset always-run)

(rule ((Top _op _x _y _z) (TernaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
        ((ExprIsPure (Top _op _x _y _z)))
        :ruleset always-run)

(rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Bop _op _x _y)))
        :ruleset always-run)

(rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
        ((ExprIsPure (Uop _op _x)))
        :ruleset always-run)

(rule ((Get _tup _i) (ExprIsPure _tup))
        ((ExprIsPure (Get _tup _i)))
        :ruleset always-run)

(rule (
        (= lhs (Get (Arg (TupleT tylist) _ctx) i))
        (!= (TypeList-ith tylist i) (StateT))
      )
      ((ExprIsPure lhs))
      :ruleset always-run)

(rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Concat _x _y)))
        :ruleset always-run)

(rule ((Single _x) (ExprIsPure _x))
        ((ExprIsPure (Single _x)))
        :ruleset always-run)

(rule ((Switch _pred _inputs _branches) (ExprIsPure _pred) (ExprIsPure _inputs) (ListExprIsPure _branches))
        ((ExprIsPure (Switch _pred _inputs _branches)))
        :ruleset always-run)

(rule ((If _pred _input _then _else) (ExprIsPure _pred) (ExprIsPure _input) (ExprIsPure _then) (ExprIsPure _else))
        ((ExprIsPure (If _pred _input _then _else)))
        :ruleset always-run)

(rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
        ((ExprIsPure (DoWhile _in _pred-and-output)))
        :ruleset always-run)

; state edge is not pure!
; (rule ((Arg _ty _ctx))
;         ((ExprIsPure (Arg _ty _ctx)))
;         :ruleset always-run)

(rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
        ((ExprIsPure (Call _f _arg)))
        :ruleset always-run)

(rule ((Empty _ty _ctx))
        ((ExprIsPure (Empty _ty _ctx)))
        :ruleset always-run)

(rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
        ((ListExprIsPure (Cons _hd _tl)))
        :ruleset always-run)

(rule ((Nil))
        ((ListExprIsPure (Nil)))
        :ruleset always-run)(ruleset select_opt)


;; inlined (Get thn i) makes the query faster ):
(rule
       (
        (= if_e (If pred inputs thn els))

        (ExprIsPure (Get thn i))
        (ExprIsPure (Get els i))
        
        (> 10 (Expr-size (Get thn i))) ; TODO: Tune these size limits
        (> 10 (Expr-size (Get els i)))
        (= (TCPair t1 c1) (ExtractedExpr (Get thn i)))
        (= (TCPair t2 c2) (ExtractedExpr (Get els i)))

        (ContextOf if_e ctx)
       )
       (
        (union (Get if_e i)
               (Top (Select) pred (TermSubst ctx inputs t1) (TermSubst ctx inputs t2)))
       )
       :ruleset select_opt
)(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(constructor ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset memory-helpers)
(constructor ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset memory-helpers)
(relation ExprSet-contains (ExprSet Expr))
(rule ((ES set1) (set-contains set1 x))
      ((ExprSet-contains (ES set1) x))
      :ruleset memory-helpers)
(constructor ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset memory-helpers)
(function ExprSet-length (ExprSet) i64 :no-merge)
(rewrite (ExprSet-length (ES set1)) (set-length set1) :ruleset memory-helpers)

; ============================
; Pointees
; ============================


; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))

(constructor UnwrapPtrPointsTo (Pointees) PtrPointees)
(rewrite (UnwrapPtrPointsTo (PtrPointsTo x))
         x
         :ruleset memory-helpers)
(constructor UnwrapTuplePointsTo (Pointees) List<PtrPointees>)
(rewrite (UnwrapTuplePointsTo (TuplePointsTo x))
         x
         :ruleset memory-helpers)

(relation PointsNowhere (Pointees))
(rule ((= f (PtrPointsTo x))
       (PointsNowhere-PtrPointees x))
      ((PointsNowhere f))
      :ruleset memory-helpers)
(rule ((= f (TuplePointsTo l))
       (All<PointsNowhere-PtrPointees> l))
      ((PointsNowhere f))
      :ruleset memory-helpers)

(constructor UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Union-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (UnionPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Union-PtrPointees> x y))
         :when ((= (Length-List<PtrPointees> x) (Length-List<PtrPointees> y)))
         :ruleset memory-helpers)
(constructor IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Intersect-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (IntersectPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Intersect-PtrPointees> x y))
         :ruleset memory-helpers)

(constructor GetPointees (Pointees i64) Pointees)
(rule ((= f (GetPointees (TuplePointsTo l) i))
       (At-List<PtrPointees> l i x))
      ((union f (PtrPointsTo x)))
      :ruleset memory-helpers)

(constructor PointeesDropFirst (Pointees) Pointees)
(rewrite (PointeesDropFirst (TuplePointsTo (Cons-List<PtrPointees> hd tl)))
         (TuplePointsTo tl)
         :ruleset memory-helpers)

; ============================
; Resolved
; ============================

; Resolved checks if an e-class contains a term containing only constructors and
; primitives; i.e. whether equality is decideable
(relation Resolved-IntOrInfinity (IntOrInfinity))
(rule ((= f (I _)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (Infinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (NegInfinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)

(relation Resolved-IntInterval (IntInterval))
(rule ((= f (MkIntInterval lo hi))
       (Resolved-IntOrInfinity lo)
       (Resolved-IntOrInfinity hi))
      ((Resolved-IntInterval f))
      :ruleset memory-helpers)

(relation Resolved-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= f (Nil-List<i64+IntInterval>)))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<i64+IntInterval> allocid offsets tl))
       (Resolved-List<i64+IntInterval> tl)
       (Resolved-IntInterval offsets))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)

(relation Resolved-PtrPointees (PtrPointees))
(rule ((= f (PointsAnywhere)))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)
(rule ((= f (PointsTo x))
       (Resolved-List<i64+IntInterval> x))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)

(relation Resolved-List<PtrPointees> (List<PtrPointees>))
(rule ((= f (Nil-List<PtrPointees>)))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<PtrPointees> hd tl))
       (Resolved-List<PtrPointees> tl)
       (Resolved-PtrPointees hd))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)

(relation Resolved-Pointees (Pointees))
(rule ((= f (TuplePointsTo x))
       (Resolved-List<PtrPointees> x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)
(rule ((= f (PtrPointsTo x))
       (Resolved-PtrPointees x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)


;;;;;

(constructor BaseTypeToPtrPointees (BaseType) PtrPointees :cost 100)
(rewrite (BaseTypeToPtrPointees (PointerT _))
         (PointsAnywhere)
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (IntT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (StateT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (BoolT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)

(constructor TypeListToList<PtrPointees> (TypeList) List<PtrPointees> :cost 1000)
(rewrite (TypeListToList<PtrPointees> (TNil))
         (Nil-List<PtrPointees>)
         :ruleset memory-helpers)
(rewrite (TypeListToList<PtrPointees> (TCons hd tl))
         (Cons-List<PtrPointees>
            (BaseTypeToPtrPointees hd)
            (TypeListToList<PtrPointees> tl))
         :ruleset memory-helpers)

(constructor TypeToPointees (Type) Pointees :cost 1000)
(rewrite (TypeToPointees (TupleT tylist))
         (TuplePointsTo (TypeListToList<PtrPointees> tylist))
         :ruleset memory-helpers)
(rewrite (TypeToPointees (Base basety))
         (PtrPointsTo (BaseTypeToPtrPointees basety))
         :ruleset memory-helpers)

; ============================
; Update PointerishType
; ============================

(relation PointerishType (Type))
(relation PointerishTypeList (TypeList))

(rule ((= f (Base (PointerT ty))))
      ((PointerishType f))
      :ruleset always-run)

(rule ((= f (TCons (PointerT ty) tl)))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TCons hd tl))
       (PointerishTypeList tl))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TupleT l))
       (PointerishTypeList l))
      ((PointerishType f))
      :ruleset always-run)

; ============================
; Update PointsToCells
; ============================

;                             arg pointees  result pointees
(constructor PointsToCells (Expr Pointees)     Pointees :unextractable) 

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (TypeToPointees in-ty)))
      :ruleset memory-helpers)

; Demand PointsToCells along state edge and pointer-typed values
(rule ((PointsToCells (Bop (Print) e state) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Top (Write) ptr val state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Alloc id sz state ty) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Free) ptr state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Get x i) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Concat x y) ap))
      ((PointsToCells x ap)
       (PointsToCells y ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Single x) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)

; Compute and propagate PointsToCells
(rewrite (PointsToCells concat-x-y aps)
         (TuplePointsTo (Concat-List<PtrPointees>
           (UnwrapTuplePointsTo (PointsToCells x aps))
           (UnwrapTuplePointsTo (PointsToCells y aps))))
         :when ((= concat-x-y (Concat x y))
                (HasType concat-x-y ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells get-x-i aps)
         (GetPointees (PointsToCells x aps) i)
         :when ((= get-x-i (Get x i))
                (HasType get-x-i ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Single x) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (UnwrapPtrPointsTo (PointsToCells x aps))
             (Nil-List<PtrPointees>)))
         :when ((HasType (Single x) ty) (PointerishType ty))
         :ruleset memory-helpers) 

(rewrite (PointsToCells (Arg ty_ ctx) aps)
         aps
         :when ((HasType (Arg ty_ ctx) ty) (PointerishType ty))
         :ruleset memory-helpers)

; Allow non-pointer types to resolve
(rule ((PointsToCells x aps)
       (HasType x ty))
      ((TypeToPointees ty))
      :ruleset memory-helpers)
(rule ((= f (PointsToCells x aps))
       (HasType x ty)
       (= pointees (TypeToPointees ty))
       (PointsNowhere pointees))
      ((union f pointees))
      :ruleset memory-helpers)

(rewrite (PointsToCells (Bop (PtrAdd) x e) aps)
         (PtrPointsTo
           (AddIntIntervalToPtrPointees
             (MkIntInterval (I lo) (I hi))
             (UnwrapPtrPointsTo (PointsToCells x aps))))
         :when ((= (IntB lo) (lo-bound e))
                (= (IntB hi) (hi-bound e)))
         :ruleset memory-helpers)

(rewrite (PointsToCells (If c inputs t e) aps)
         (UnionPointees
           (PointsToCells t (PointsToCells inputs aps))
           (PointsToCells e (PointsToCells inputs aps)))
         :when ((HasType (If c inputs t e) ty) (PointerishType ty))
         :ruleset memory)

(rewrite (PointsToCells (Alloc id sz state ty) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (PointsTo
               (Cons-List<i64+IntInterval>
                 id
                 (MkIntInterval (I 0) (I 0))
                 (Nil-List<i64+IntInterval>)))
             (Cons-List<PtrPointees>
               (PointsTo (Nil-List<i64+IntInterval>)) ; state output points to nothing
               (Nil-List<PtrPointees>))))
         :ruleset memory-helpers)

; arg pointees * loop in * loop out * i64 -> result pointees
(constructor PointsToCellsAtIter (Pointees Expr Expr i64) Pointees)

; compute first two
(rule ((= e (DoWhile inputs pred-body))
       (PointsToCells e aps))
      ((set (PointsToCellsAtIter aps inputs pred-body 0)
            (PointsToCells inputs aps))
       (set (PointsToCellsAtIter aps inputs pred-body 1)
            (UnionPointees
              (PointsToCellsAtIter aps inputs pred-body 0)
              (PointeesDropFirst
                (PointsToCells pred-body (PointsToCellsAtIter aps inputs pred-body 0))))))
      :ruleset memory-helpers)

; avoid quadratic query
(function succ (i64) i64 :no-merge)
(rule ((PointsToCellsAtIter aps inputs pred-body i))
      ((set (succ i) (+ i 1)))
      :ruleset memory-helpers)

; Note that this rule is bounded by ruleset memory
(rule ((= pointees0 (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees1 (PointsToCellsAtIter aps inputs pred-body (succ i)))
       (Resolved-Pointees pointees0)
       (Resolved-Pointees pointees1)
       (!= pointees0 pointees1))
      ((set (PointsToCellsAtIter aps inputs pred-body (+ i 2))
            (UnionPointees
              pointees1
              (PointeesDropFirst
                (PointsToCells pred-body pointees1)))))
      :ruleset memory)

(rule ((= pointees (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees (PointsToCellsAtIter aps inputs pred-body (succ i))))
      ((set (PointsToCells (DoWhile inputs pred-body) aps)
            pointees))
      :ruleset memory)

(rule ((PtrPointsTo (PointsTo l)))
      ((DemandAt-List<i64+IntInterval> l))
      :ruleset memory-helpers)
(rule ((TuplePointsTo l))
      ((DemandAt-List<PtrPointees> l))
      :ruleset memory-helpers)

; ============================
; Update DontAlias
; ============================

(relation DemandDontAlias (Expr Expr Pointees))
;                    pointer, pointer, arg pointees
(relation DontAlias (Expr Expr Pointees))


(rule ((DemandDontAlias ptr1 ptr2 arg-pointees)
       (BodyContainsExpr body ptr1)
       (BodyContainsExpr body ptr2)
       (HasType ptr1 (Base (PointerT ty)))
       (HasType ptr2 (Base (PointerT ty)))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset memory-helpers)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((DontAlias ptr1 ptr2 arg-pointees))
      :ruleset memory-helpers)

; ============================
; Update PointsToExpr
; ============================

;                       program point, pointer
(constructor PointsToExpr (Expr           Expr) Expr :unextractable)

; After a load, the ptr points to the loaded value
(rule ((= f (Bop (Load) ptr state)))
      ((set (PointsToExpr (Get f 1) ptr) (Get f 0)))
      :ruleset memory-helpers)

; If we load and we already know what the pointer points to
; TODO this rule breaks the weakly linear invariant
; when a previous load may not be on the path
;(rule ((= e (Bop (Load) addr state))
;       (= v (PointsToExpr state addr)))
;      ((union (Get e 0) v)
;       (union (Get e 1) state))
;       :ruleset memory-helpers)

; Loads and prints don't affect what what pointers already point to
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Load) any-addr state)))
      ((let new-state (Get e 1))
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Print) any-val state)))
      ((let new-state e)
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)

; Writes don't affect what a pointer points to if it writes to another pointer
; guaranteed to not alias.
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr)))
      ((DemandDontAlias addr otheraddr (TypeToPointees argty)))
      :ruleset memory-helpers)
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr))
       (DontAlias addr otheraddr (TypeToPointees argty)))
      ((set (PointsToExpr e otheraddr) otherdata))
      :ruleset memory-helpers)

; For a write, mark the given expression as containing `data`.
(rule ((= e (Top (Write) addr data state)))
      ((union (PointsToExpr e addr) data))
      :ruleset memory-helpers)

; ============================
; Update CellHasValues (currently unused)
; ============================

; ;                       program point, cell
; (constructor CellHasValues (Expr i64) ExprSet :merge (ExprSet-intersect old new))

; ; At the time of an alloc, a cell doesn't contain any values
; (rule ((= f (Alloc id amt state ty)))
      ; ((set (CellHasValues (Get f 1) id) (ES (set-empty))))
      ; :ruleset memory-helpers)

; ; These two rules find (Write ptr val state) where 
; ; ptr points to cells given no assumptions about where (Arg) points.
; ; TODO: make sensitive to offsets
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty))
      ; ((TypeToPointees argty))
      ; :ruleset memory-helpers)
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty)
       ; (= (PtrPointsTo (PointsTo cells)) (PointsToCells ptr (TypeToPointees argty)))
       ; (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       ; (= vals (CellHasValues state cell)))
      ; ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      ; :ruleset memory-helpers)
;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)

;;                      inputs, outputs -> number of iterations
;; The minimum possible guess is 1 because of do-while loops
;; TODO: dead loop deletion can turn loops with a false condition to a body
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset loop-iters-analysis)

;; For a loop that is false, its num iters is 1
(rule 
  ((= loop (DoWhile inputs outputs))
   (= (Const (Bool false) ty ctx) (Get outputs 0)))
  ((set (LoopNumItersGuess inputs outputs) 1))
:ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated before checking pred
;; TODO: we could make it work for decrementing loops
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by some constant each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while next_counter less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (/ (- end_constant start_const) increment))
  )
  :ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated after checking pred
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   (= body-arg (Get (Arg _ty _ctx) counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by a constant each loop
   (= next_counter (Bop (Add) body-arg
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while this counter less than end_constant
   (= pred (Bop (LessThan) body-arg
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (+ (/ (- end_constant start_const) increment) 1))
  )
  :ruleset loop-iters-analysis)

;; loop peeling rule
;; Only peel loops that we know iterate < 3 times
(constructor LoopPeeledPlaceholder (Expr) Assumption :unextractable)
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs))
  (< old_cost 3)
  )
 (
  (let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))

  (let new-loop-arg
    (Arg inputs-ty then-ctx))
  (let new-loop-body
    (Subst (LoopPeeledPlaceholder lhs) new-loop-arg outputs))
  (union (InLoop new-loop-arg new-loop-body) (LoopPeeledPlaceholder lhs))

  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
      executed-once-body ;; inputs are the body executed once
      (DoWhile new-loop-arg new-loop-body)
      (Arg inputs-ty else-ctx)))

  (set (LoopNumItersGuess new-loop-arg new-loop-body) (- old_cost 1))
  )
 :ruleset loop-peel)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst (TmpCtx) one-iter
          (Subst (TmpCtx) one-iter
            (Subst (TmpCtx) one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union (TmpCtx) actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
    (delete (TmpCtx))
  )
  :ruleset loop-unroll)


(relation IVTNewInputsAnalysisDemand (Expr))

(ruleset ivt-analysis)

(sort IVTRes)
;;                              perm passthrough-perm passthrough-type passthrough-type-len
(constructor IVTAnalysisRes (Expr Expr             TypeList         i64) IVTRes)
(constructor IVTMin (IVTRes IVTRes) IVTRes)

(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (<= len1 len2))
      ((union lhs (IVTAnalysisRes _a _b _c len1)))
        :ruleset ivt-analysis)
(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (> len1 len2))
      ((union lhs (IVTAnalysisRes _d _e _f len2)))
        :ruleset ivt-analysis)


;; use an analysis to avoid exploring all combinations of passthrough vs not passed through values. Always prefer not passed through
;;                                  expr1 curr  if  result
(function IVTNewInputsAnalysisImpl (Expr  Expr  Node) IVTRes :merge (IVTMin old new))

;; IVTNewInputsAnalysis computes a permutation perm which corresponds to accessing elements of an if region.
;; It also makes accesses of passthrough arguments access new indices after the length of the if region.
;; For example, if expr1 is: [get(if, 1), get(arg, 1), get(if, 0), get(arg, 3)]
;; It produces a new permutation: [get(arg, 1), get(arg, 2), get(arg, 0), get(arg, 3)]
;; The accesses of the if statement remain unchanged, and the accesses of the passthrough arguments are moved to the end.
;; This new permutation is intended to be used with a substitution argument (Concat if-statement passthrough-args)
;; Also produced is a passthrough-perm, which selects all of the passthrough arguments and puts them in a single tuple
;;                              expr1 if result
(function IVTNewInputsAnalysis (Expr  Node) IVTRes :merge (IVTMin old new))


(rule (
    (DoWhile inpW outW)
) (
    (IVTNewInputsAnalysisDemand outW)
) :ruleset ivt-analysis)

(rule (
    (IVTNewInputsAnalysisDemand loop-body)
    ;; first input is a predicate
    (= loop-body (Concat (Single pred) rest))
    ;; another input is an if statement with shared predicate
    (= if-eclass (If pred inputs thn else))
    (= (Get loop-body i) (Get if-eclass j))
    (!= i 0)
) (
    (let perm (Empty (TmpType) (InFunc "no-ctx")))
    (set
     (IVTNewInputsAnalysisImpl loop-body rest (IfNode if-eclass pred inputs thn else))
     (IVTAnalysisRes perm perm (TNil) 0))
) :ruleset ivt-analysis)

;; recursive case for accessing the if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get if-eclass ith)) rest))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm  pperm passthrough-tys len))
) :ruleset ivt-analysis)

;; recursive case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get (Arg ty ctx) ith)) rest))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)

; base case for accessing if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body (Single last) ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= last (Get if-eclass ith))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm pperm passthrough-tys len))
) :ruleset ivt-analysis)

; base case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Single (Get (Arg ty ctx) ith)))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)


(ruleset loop-inversion)

(rule (
    (= loop (DoWhile inpW outW))
    (= (IVTNewInputsAnalysis outW ifnode) (IVTAnalysisRes perm pperm passthrough-tys _len))
    (= ifnode (IfNode if if-cond if-inputs then else))
    (= if-inputs-len (tuple-length if-inputs))
    (= passthrough-len (TypeList-length passthrough-tys))

    (ContextOf inpW outer-ctx)
    (ContextOf if-inputs if-ctx)
    (HasType if-inputs inputs-ty)
    (= inputs-ty (TupleT inputs-ty-list))
) (
    ;; new peeled condition, checks the if's condition before the first iteration
    (let new-if-cond (Subst outer-ctx inpW if-cond))

    ;; new inputs to the if are 1) the inputs run once unconditionally concatted with
    ;; 2) the passthrough values
    (let new-if-inp
        (Concat (Subst outer-ctx inpW if-inputs)
                (Subst outer-ctx inpW pperm)))
    ;; if contexts
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-arg-ty (TupleT (TLConcat inputs-ty-list passthrough-tys)))
    (let new-loop-arg (Arg new-loop-arg-ty (TmpCtx)))
    (let new-loop-context (TmpCtx))

    ;; body
    ;; loop begins by running the then branch of the if statement, which uses the first if-inputs-length elements of arg
    (let then-arg (SubTuple new-loop-arg 0 if-inputs-len))
    (let new-then-branch
        (Subst new-loop-context then-arg then))
    ;; the inputs are then run on the combination of
    ;; the then branch and the passthrough values
    (let then-branch-and-passthrough
      (Concat new-then-branch (SubTuple new-loop-arg if-inputs-len passthrough-len)))
    ;; permute them to move passthrough and if outputs back
    ;; to where if-inputs and if-cond expect them to be
    (let permuted-then-branch-and-passthrough
      (Subst new-loop-context then-branch-and-passthrough perm))
    ;; substitute into inputs and condi
    (let new-inputs-after-then-branch 
        (Subst new-loop-context permuted-then-branch-and-passthrough
            (Concat (Single if-cond) if-inputs)))
    (let new-loop-outputs
        (Concat new-inputs-after-then-branch
           (SubTuple new-loop-arg if-inputs-len passthrough-len)))

    (let new-loop (DoWhile (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg new-loop-arg-ty new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let final-if-inputs
       (SubTuple new-if 0 if-inputs-len))
    (let else-branch-end
        (Subst outer-ctx final-if-inputs else))
    (let else-branch-end-and-passthrough
        (Concat else-branch-end
               (SubTuple new-if if-inputs-len passthrough-len)))
    (let final-permuted
        (Subst outer-ctx else-branch-end-and-passthrough perm))

    (union final-permuted loop)
    (union new-loop-context (InLoop (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))

    (subsume (DoWhile inpW outW))
    (delete (TmpCtx))
) :ruleset loop-inversion)
;; Hacker's delight optimizations

(ruleset hacker)

;; A simple analysis to identify loops that run exactly #popcount times

;; IsIsEven e x => e is a boolean expression that checks whether x is an even number
(relation IsIsEven (Expr Expr))

(rule (
    (= two (Const (Int 2) ty ctx))
    (= e (Bop (Eq) x (Bop (Mul) (Bop (Div) x two) two)))
) (
    (IsIsEven e x)
) :ruleset hacker)

;; NTZIterations lp n pos => loop lp runs exactly number_of_trailing_zeros(n) times at index pos
(relation NTZIterations (Expr Expr i64))

(rule (
    ;; Grab the outer if
    (= outerif (If cond inputs evenbr oddbr))
    ;; There exists an argument n
    (= n (Get inputs i))
    ;; The condition is on the parity of n
    (IsIsEven cond n)
    ;; In the even/true branch, there is a loop
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    ;; n is passed into to the loop
    (= (Get lp_inputs j) (Get (Arg _ty1 _ctx1) i))
    ;; the loop continues as long as n / 2 is even
    (= two (Const (Int 2) _ty2 _ctx2))
    (= nd2 (Bop (Div) (Get (Arg _ty3 _ctx3) j) two))
    (IsIsEven (Get lp_pred_outputs 0) nd2)
    ;; n is divided by 2 every loop
    (= nd2 (Get lp_pred_outputs (+ j 1)))
    ;; In the odd/false branch, we look for an n
    (= (Get (Arg _ty4 _ctx4) i) (Get oddbr j))
) (
    (NTZIterations outerif n j)
) :ruleset hacker)

;; Identify and optimize lowbit

(rule (
    (NTZIterations outerif n i)
    (= outerif (If cond inputs evenbr oddbr))
    ;; In the even branch, it returns a value that doubles every iter
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    (= (Const (Int 1) _ty1 _ctx1) (Get lp_inputs j))
    (= two (Const (Int 2) _ty2 _ctx2))
    (= (Bop (Mul) (Get (Arg _ty3 _ctx3) j) two) (Get lp_pred_outputs (+ j 1)))    
    ;; In the odd branch, it returns an 1
    (= (Const (Int 1) _ty0 _ctx0) (Get oddbr j))
) (
    (let lowbitn (Bop (Bitand) n (Uop (Neg) n)))
    (union (Get outerif j) lowbitn)
    (union (Get outerif i) (Bop (Div) n lowbitn))
) :ruleset hacker)

;; Try to do a state-edge-passthrough for loops
;; NLZIterations guarantees termination for non-zero values
;; lowbit(0) is undefined behavior

(constructor DummyLoopContext (Expr Expr Expr) Assumption)

(rule (
    (NTZIterations anyif n i)
    (= anyif (If cond inputs thenbr elsebr))
    (= thenbr (DoWhile lpinputs pred_outputs))
    (= (Get pred_outputs (+ j 1)) (Get (Arg arg_ty then_ctx) j))
    (HasType (Get pred_outputs (+ j 1)) (Base (StateT)))
) (
    (let newlpinputs (TupleRemoveAt lpinputs j))
    (let newpred_outputs (TupleRemoveAt pred_outputs (+ j 1)))
    
    (let newlpctx (DummyLoopContext newlpinputs newpred_outputs pred_outputs))

    (let newbody (DropAt newlpctx j newpred_outputs))

    (union newlpctx (InLoop newlpinputs newbody))

    (let newlp (DoWhile newlpinputs newbody))
    (let oldlp (TupleRemoveAt thenbr j))

    (union newlp oldlp)

    (union (Get thenbr j) (Get lpinputs j))

) :ruleset hacker);; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)


(function hoisted-loop (Expr Expr) bool :merge (or old new) )
(rule ((= loop (DoWhile in pred_out)))
      ((set (hoisted-loop in pred_out) false)) :ruleset always-run)

(constructor InExtendedLoop (Expr Expr Expr) Assumption)

;; mock function
(ruleset loop-inv-motion)

(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in pred_out))
       ;; the outter assumption of the loop 
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= false (hoisted-loop in pred_out))
       (= len (tuple-length in)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))

       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (InExtendedLoop in pred_out new_input))
       (let new_out_branch (Get (Arg new_input_type assum) len))

       ;; this two subst only change arg to arg with new type
       (let substed_pred_out
         (Subst assum
               (SubTuple (Arg new_input_type assum) 0 len) pred_out))
       (let inv_in_new_loop
            (Subst assum (SubTuple (Arg new_input_type assum) 0 len) inv))
       (let new_pred_out (Concat substed_pred_out (Single new_out_branch)))
       
       (let new_loop (DoWhile new_input new_pred_out))
       (union assum (InLoop new_input new_pred_out))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in pred_out)) 
       ;; don't hoist same loop again
       (set (hoisted-loop in pred_out) true)
      )
       :ruleset loop-inv-motion)
; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

; use TmpType for helpers where the type doesn't matter
; these shouldn't appear in values in the program, only intermediate terms (such as in ivt.egg permutations)
(constructor TmpType () Type)

(constructor TNil () TypeList)
(constructor TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Assumptions
; =================================

(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf bool Expr Expr)
)



; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(constructor Arg (Type Assumption) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool)
  (Float f64))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(constructor Const (Constant Type Assumption) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(constructor Empty (Type Assumption) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write)
  (Select))
(datatype BinaryOp
  ;; Bitwise operators
  (Bitand)
  ;; integer operators
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (Smin)
  (Smax)
  (Shl)
  (Shr)
  ;; float operators 
  (FAdd)
  (FSub)
  (FDiv)
  (FMul)
  (FLessThan)
  (FGreaterThan) 
  (FLessEq)
  (FGreaterEq)
  (FEq)
  (Fmin)
  (Fmax)
  ;; logical operators
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Neg)
  (Abs)
  (Not))

; Operators
(constructor Top   (TernaryOp Expr Expr Expr) Expr)
(constructor Bop   (BinaryOp Expr Expr) Expr)
(constructor Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(constructor Get   (Expr i64) Expr)
; (Alloc id amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns (pointer to the allocated memory, state edge)
(constructor Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(constructor Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(constructor Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 expr1       expr2
(constructor Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; pred must be an integer
;                 pred  inputs   branches     chosen
(constructor Switch (Expr  Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred inputs   then else
(constructor If (Expr Expr     Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple 
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(constructor DoWhile (Expr    Expr)                   Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(constructor Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(constructor Function (String Type      Type       Expr)      Expr)

; to get the type of a funciton, look in this table
; since we might not be optimizing the entire program
(relation FunctionHasType (String Type Type))

; Rulesets
(ruleset always-run)
(ruleset is-resolved)
(ruleset error-checking)
(ruleset memory)
(ruleset memory-helpers)
(ruleset smem)

;; Initliazation
(relation bop->string (BinaryOp String))
(relation uop->string (UnaryOp String))
(relation top->string (TernaryOp String))
(bop->string (Add) "Add")
(bop->string (Sub) "Sub")
(bop->string (Div) "Div")
(bop->string (Mul) "Mul")
(bop->string (LessThan) "LessThan")
(bop->string (GreaterThan) "GreaterThan")
(bop->string (LessEq) "LessEq")
(bop->string (GreaterEq) "GreaterEq")
(bop->string (Eq) "Eq")
(bop->string (FAdd) "FAdd")
(bop->string (FSub) "FSub")
(bop->string (FDiv) "FDiv")
(bop->string (FMul) "FMul")
(bop->string (FLessThan) "FLessThan")
(bop->string (FGreaterThan) "FGreaterThan")
(bop->string (FLessEq) "FLessEq")
(bop->string (FGreaterEq) "FGreaterEq")
(bop->string (FEq) "FEq")
(bop->string (And) "And")
(bop->string (Or) "Or")
(bop->string (Load) "Load")
(bop->string (PtrAdd) "PtrAdd")
(bop->string (Print) "Print")
(bop->string (Free) "Free")

;; If anything is put in the DebugExpr relation, we'll extract them instead of the original program.
;; These can then be visualized using the `optimized-rvsdg` run mode
(relation DebugExpr (Expr))

; TERMS
(datatype Term)
(datatype ListTerm (TermCons Term ListTerm) (TermNil))

; TODO: Will probably need ctx so that we can resubstitute?
; (datatype TermAssumption
;   ; Assume nothing
;   (InFunc String)
;   ; The term is in a loop with `input` and `pred_output`.
;   ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
;   ;      input    pred_output
;   (InLoop Term     Term)
;   ; Branch of the switch, and what the predicate is, and what the input is
;   (InSwitch i64 Term Term)
;   ; If the predicate was true, and what the predicate is, and what the input is
;   (InIf bool Term Term)
; )

(constructor TermArg () Term)

(constructor TermConst (Constant) Term)

(constructor TermEmpty () Term)

; Term Operators
(constructor TermTop (TernaryOp Term Term Term) Term)
(constructor TermBop (BinaryOp Term Term) Term)
(constructor TermUop (UnaryOp Term) Term)
(constructor TermGet (Term i64) Term)
(constructor TermAlloc (i64 Term Term BaseType) Term)
(constructor TermCall (String Term) Term)

; Tuple Operators
(constructor TermSingle (Term) Term)
(constructor TermConcat (Term Term) Term)

; Control Flow (TODO? Not sure if needed)
; (constructor TermSwitch (Term Term ListTerm) Term)
; (constructor TermIf (Term Term Term Term) Term)

; (constructor TermDoWhile (Term Term) Term)


(ruleset never); We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

(rule ((Arg ty ctx))
      ((ContextOf (Arg ty ctx) ctx))
      :ruleset always-run)
(rule ((Const c ty ctx))
      ((ContextOf (Const c ty ctx) ctx))
      :ruleset always-run)
(rule ((Empty ty ctx))
      ((ContextOf (Empty ty ctx) ctx))
        :ruleset always-run)

; Error checking - each expr should only have a single context
(rule ((ContextOf x ctx1)
       (ContextOf x ctx2)
       (!= ctx1 ctx2))
     (
         (panic "Equivalent expressions have nonequivalent context, breaking the single context invariant.")
     )
     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred inputs branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred inputs branches) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf pred ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((If pred inputs then else) (ContextOf inputs ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)
;; Like Subst but for dropping inputs to a region
;; See subst.egg for more implementation documentation

(ruleset drop)
(ruleset apply-drop-unions)
(ruleset cleanup-drop)

;; (DropAt ctx idx in) removes all references to `(Get (Arg ...) idx)` in `in`.
;; It also replaces the leaf contexts with `ctx` and fixes up argument types,
;; as well as updating `(Get (Arg ...) j)` to `(Get (Arg ...) (- j 1))` for j > idx.
(constructor DropAt (Assumption i64 Expr) Expr :unextractable)
(constructor DelayedDropUnion (Expr Expr) Expr :unextractable)

;; Helper that precomputes the arg type that we need
(constructor DropAtInternal (Type Assumption i64 Expr) Expr :unextractable)
(rule ((= lhs (DropAt ctx idx in))
       (HasArgType in (TupleT oldty)))

      ((let newty (TupleT (TypeListRemoveAt oldty idx)))
       (union lhs (DropAtInternal newty ctx idx in)))
      :ruleset drop)

;; Leaves
(rule ((= lhs (DropAtInternal newty newctx idx (Const c oldty oldctx))))
      ((DelayedDropUnion lhs (Const c newty newctx)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Empty oldty oldctx))))
      ((DelayedDropUnion lhs (Empty newty newctx)))
      :ruleset drop)
; get stuck on purpose if `i = idx` or if we find a bare `Arg`
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (< i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) i)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (> i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) (- i 1))))
      :ruleset drop)

;; Operators
(rule ((= lhs (DropAtInternal newty newctx idx (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedDropUnion lhs (Top op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            (DropAtInternal newty newctx idx c3))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedDropUnion lhs (Bop op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedDropUnion lhs (Uop op
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; this is okay because we get stuck at `Arg`s
(rule ((= lhs (DropAtInternal newty newctx idx (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedDropUnion lhs (Get
            (DropAtInternal newty newctx idx c1)
            index)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedDropUnion lhs (Alloc id
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            ty)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedDropUnion lhs (Call name
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; Tuple operators
(rule ((= lhs (DropAtInternal newty newctx idx (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedDropUnion lhs (Single
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedDropUnion lhs (Concat
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

;; Control flow
(rule ((= lhs (DropAtInternal newty newctx idx (Switch pred inputs c1)))
       (ExprIsResolved (Switch pred inputs c1)))
      ((DelayedDropUnion lhs (Switch
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (If pred inputs c1 c2)))
       (ExprIsResolved (If pred inputs c1 c2)))
      ((DelayedDropUnion lhs (If
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1
            c2)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedDropUnion lhs (DoWhile
            (DropAtInternal newty newctx idx in)
            out)))
      :ruleset drop)

(rewrite (DropAtInternal newty newctx idx (Function name inty outty body))
         (Function name inty outty (DropAtInternal newty newctx idx body))
         :when ((ExprIsResolved body))
         :ruleset drop)



;; ########################### Apply drop unions

(rule ((DelayedDropUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-drop-unions)

;; ########################### Cleanup Dropat, DropAtInternal and DelayedDropUnion

(rule ((ExprIsResolved (DropAt newctx idx in)))
      ((subsume (DropAt newctx idx in)))
      :ruleset cleanup-drop)

(rule ((ExprIsResolved (DropAtInternal newty newctx idx in)))
      ((subsume (DropAtInternal newty newctx idx in)))
      :ruleset cleanup-drop)

(rule ((DelayedDropUnion lhs rhs))
      ((subsume (DelayedDropUnion lhs rhs)))
      :ruleset cleanup-drop)
(ruleset term-subst)


; Instantiate the term as an Expr in the provided context
; where references to (Arg) in the term are replaced by Expr
(constructor TermSubst (Assumption Expr Term) Expr :unextractable)

; type rule to get the arg type of a substitution
(rule (
        (= lhs (TermSubst ctx e1 term))
        (HasArgType e1 ty)       
      )
      ((HasArgType lhs ty))
      :ruleset term-subst)


; leaf node
; replace the context
(rule ((= lhs (TermSubst ctx e (TermArg))))
      ((union lhs (AddContext ctx e)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConst c)))
       (HasArgType e newty))
      ((union lhs (Const c newty ctx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermEmpty)))
       (HasArgType e newty))
      ((union lhs (Empty newty ctx)))
      :ruleset term-subst)

; Operators
(rule ((= lhs (TermSubst ctx e (TermTop op t1 t2 t3))))
      ((union lhs (Top op (TermSubst ctx e t1)
                          (TermSubst ctx e t2)
                          (TermSubst ctx e t3))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermBop op t1 t2))))
      ((union lhs (Bop op (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermUop op t1))))
      ((union lhs (Uop op (TermSubst ctx e t1))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermGet t idx))))
      ((union lhs (Get (TermSubst ctx e t) idx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermAlloc id t1 t2 ty))))
      ((union lhs (Alloc id (TermSubst ctx e t1)
                            (TermSubst ctx e t2)
                            ty)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermCall name t))))
      ((union lhs (Call name (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermSingle t))))
      ((union lhs (Single (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConcat t1 t2))))
      ((union lhs (Concat (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

; Control Flow
; TODO(ruleset terms)
;; helpers keeps track of the new best extracted terms
(ruleset terms-helpers)
;; helpers-helpers runs `Smaller` rules, resolving the merge function for helpers
(ruleset terms-helpers-helpers)

(sort TermAndCost)
(constructor Smaller (TermAndCost TermAndCost) TermAndCost)

(function ExtractedExpr (Expr) TermAndCost
  :merge (Smaller old new))
;; potential extractions- use so that when the costs are equal, we don't change the term
;; this preserves egglog's timestamp of when the last time ExtractedExpr was changed, fixing a big performance problem
(relation PotentialExtractedExpr (Expr TermAndCost))

(constructor TCPair (Term i64) TermAndCost)

(constructor NoTerm () Term)

;; set extracted expr to default value
(rule ((PotentialExtractedExpr expr termandcost))
      ((set (ExtractedExpr expr) (TCPair (NoTerm) 10000000000000000)))
      :ruleset terms-helpers)

;; set extracted expr to new value as long as not equal
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (= (ExtractedExpr expr) (TCPair oldterm oldcost))
       (< cost oldcost))
      ((set (ExtractedExpr expr) (TCPair term cost)))
      :ruleset terms-helpers)

;; if the cost is negative panic, terms got too big
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (< cost 0))
      ((panic "Negative cost"))
      :ruleset terms-helpers)

;; Resolve Smaller
(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (< cost1 cost2)
      )
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)

(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (> cost1 cost2) 
      )
      ((union lhs (TCPair t2 cost2)))
      :ruleset terms-helpers-helpers)


(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (= cost1 cost2) 
      )
      ;; arbitrarily pick first one
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)


; Compute smallest Expr bottom-up
(rule ((= lhs (Const c ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermConst c) 1)))
      :ruleset terms)

(rule ((= lhs (Arg ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermArg) 1)))
      :ruleset terms)

(rule (
        (= lhs (Bop o e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermBop o t1 t2) (+ 1 (+ c1 c2)))))
      :ruleset terms)

(rule (
        (= lhs (Top o e1 e2 e3))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (= (TCPair t3 c3) (ExtractedExpr e3))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermTop o t1 t2 t3) (+ (+ 1 c1) (+ c2 c3)))))
      :ruleset terms)

(rule (
        (= lhs (Uop o e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermUop o t1) (+ 1 c1))))
      :ruleset terms)

(rule (
        (= lhs (Get tup i))
        (= (TCPair t1 c1) (ExtractedExpr tup))
      )
      ; cost of the get is the same as the  cost of the whole tuple
      ((PotentialExtractedExpr lhs (TCPair (TermGet t1 i) c1)))
      :ruleset terms)

; todo Alloc

; todo Call

(rule (
        (= lhs (Single e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ; cost of single is same as cost of the element
      ((PotentialExtractedExpr lhs (TCPair (TermSingle t1) c1)))
      :ruleset terms)

(rule (
        (= lhs (Concat e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ; cost of concat is sum of the costs
      ((PotentialExtractedExpr lhs (TCPair (TermConcat t1 t2) (+ c1 c2))))
      :ruleset terms)


; todo Control flow - not sure if needed
; (rule (
;         (= lhs (If pred inputs thn els))
;         (= (TCPair t1 c1) (ExtractedExpr pred))
;         (= (TCPair t2 c2) (ExtractedExpr inputs))
;         (= (TCPair t3 c3) (ExtractedExpr thn))
;         (= (TCPair t4 c4) (ExtractedExpr els))
;       )
;       ; cost of if is 10 + cost of pred + cost of input + max of branch costs
;       ((PotentialExtractedExpr lhs (TCPair (TermIf t1 t2 t3 t4) (+ 10 (+ (+ c1 c2) (max c3 c4))))))
;       :ruleset terms)

(sort Node)
;; store a particular if node for later
;; stored as the if eclass, pred, inputs, then, else
(constructor IfNode (Expr Expr Expr Expr Expr) Node)
;; Compute the tree size of program, not dag size
(function Expr-size (Expr) i64 :merge (min old new) )
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(rule ((= expr (Function name tyin tyout out)) 
       (= sum (Expr-size out))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty assum))) 
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Top op x y z))
       (= sum (+ (Expr-size z) (+ (Expr-size y) (Expr-size x)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Bop op x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i)) 
       (= sum (Expr-size tup))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred inputs branches)) 
       (= sum  (+ (Expr-size inputs) (+ (ListExpr-size branches) (Expr-size pred)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred inputs then else)) 
       (= sum (+ (Expr-size inputs) (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output)) 
       (= sum (+ (Expr-size pred-and-output) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty assum))) 
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg)) 
       (= sum (Expr-size arg))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty assum)) ((set (Expr-size (Empty ty assum)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl)) 
       (= sum (+ (ListExpr-size tl) (Expr-size hd)))) 
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil)) 
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc id e state ty)) ;; do state edge's expr should be counted?
        (= sum (Expr-size e))) 
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)
;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(constructor Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(constructor DelayedSubstUnion (Expr Expr) Expr :unextractable)

;; add a type rule to get the arg type of a substitution
;; this enables nested substitutions
(rule ((= lhs (Subst assum to in))
       (HasArgType to ty))
      ((HasArgType lhs ty))
      :ruleset subst)

;; Substitution typechecks only when the type of the
;; argument matches the type of the substitution.
(rule ((Subst assum to in)
       (HasArgType in ty)
       (HasType to ty2)
       (!= ty ty2)
       ;; tmptype disables typechecking
       (!= ty (TmpType))
       (!= ty2 (TmpType)))
      ((extract "Extracting type mismatch")
       (extract ty)
       (extract ty2)
       (panic "Substitution type mismatch! Argument type must match type of substituted term"))
       :ruleset subst)


;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to e))
       (= e (Arg _ty _oldctx))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Const c _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Const c newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Empty _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Empty newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)

;; Operators
(rule ((= e (Top op c1 c2 c3))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Top op (Subst assum to c1)
                 (Subst assum to c2)
                 (Subst assum to c3)))
       (subsume (Subst assum to e)))
         :ruleset subst)

(rule ((= e (Bop op c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Bop op (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Uop op c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Uop op (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)    

(rule ((= e (Get c1 index))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Get (Subst assum to c1) index))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Alloc id c1 c2 ty))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Alloc id (Subst assum to c1)
                   (Subst assum to c2)
                   ty))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Call name c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Call name (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)


;; Tuple operators
(rule ((= e (Single c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Single (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Concat c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Concat (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)

;; Control flow
(rule ((= lhs (Subst assum to inner))
       (= inner (Switch pred inputs c1))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 c1))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= lhs (Subst assum to inner))
       (= inner (If pred inputs c1 c2))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= e (DoWhile in out))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (DoWhile (Subst assum to in)
                  out))
       (subsume (Subst assum to e)))
      :ruleset subst)

;; substitute into function (convenience for testing)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :when ((ExprIsResolved body))
         :ruleset subst)



;; ########################### Apply subst unions

(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)
(function ListExpr-length (ListExpr) i64 :no-merge)
(constructor ListExpr-ith (ListExpr i64) Expr :unextractable)
(constructor ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(constructor Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred inputs branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :no-merge)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)


;; Leading expressions are tuples that are used as a whole
;; during optimization and are matched in the query.
(relation leading-Expr (Expr))
(relation leading-Expr-list (ListExpr))

(rule ((= e (DoWhile inputs pred_out)))
      ((leading-Expr e)
       (leading-Expr inputs)
       (leading-Expr pred_out))
      :ruleset always-run)
(rule ((= e (If cond inputs thn els)))
       ((leading-Expr e)
        (leading-Expr inputs)
        (leading-Expr thn)
        (leading-Expr els))
       :ruleset always-run)
(rule ((= e (Switch pred inputs branch)))
      ((leading-Expr e)
       (leading-Expr-list branch)
       (leading-Expr inputs))
       :ruleset always-run)
(rule ((leading-Expr-list (Cons hd tl)))
      ((leading-Expr hd)
       (leading-Expr-list tl))
      :ruleset always-run)
(rule ((= e (Arg t a)))
      ((leading-Expr e))
      :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((leading-Expr tuple)
       (> (tuple-length tuple) 0))
      ((Get tuple 0))
      :ruleset always-run)
;; next get
(rule ((leading-Expr tuple)
       (= len (tuple-length tuple))
       (= ith (Get tuple i))
       (< (+ i 1) len)
       )
       ((Get tuple (+ 1 i)))
       :ruleset always-run)

(constructor List-suffix (Expr i64) Expr)
(rule ((Get x i))
      ((union (List-suffix x 0) x))
      :ruleset always-run)
(rule ((= (List-suffix x n) (Concat (Single hd) tl)))
      ((union (List-suffix x (+ n 1)) tl))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Concat (Single e) rest)))
      ((union lhs e))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Single e)))
      ((union lhs e))
      :ruleset always-run)

;; A temporary context.
;; Be sure to delete at the end of all actions or else!!!
;; This is safer than using a persistant context, since we may miss an important part of the query.
(constructor TmpCtx () Assumption)

(rule ((TmpCtx))
  ((panic "TmpCtx should not exist outside rule body"))
  :ruleset always-run)


(ruleset subsume-after-helpers)
;; After running the `saturating` ruleset, these if statements can be subsumed
(relation ToSubsumeIf (Expr Expr Expr Expr))
;; Workaround of https://github.com/egraphs-good/egglog/issues/462
;; Make sure the if we are subsuming is present
(rule ((ToSubsumeIf a b c d)
       (If a b c d))
      ((subsume (If a b c d)))
      :ruleset subsume-after-helpers)

(ruleset add-to-debug-expr)
;; use these rules to clean up the database, removing helpers
;; this makes the visualization easier to read

(ruleset debug-deletes)

(rule ((HasType a b))
      ((delete (HasType a b)))
      :ruleset debug-deletes)

(rule ((BodyContainsExpr a b))
      ((delete (BodyContainsExpr a b)))
      :ruleset debug-deletes)

(rule ((ExprIsPure e))
      ((delete (ExprIsPure e)))
      :ruleset debug-deletes)

(rule ((HasArgType e ty))
      ((delete (HasArgType e ty)))
      :ruleset debug-deletes)

(rule ((is-inv-Expr e ty))
      ((delete (is-inv-Expr e ty)))
      :ruleset debug-deletes)

(rule ((tuple-length e))
      ((delete (tuple-length e)))
      :ruleset debug-deletes)

(rule ((BinaryOpIsPure e))
      ((delete (BinaryOpIsPure e)))
      :ruleset debug-deletes)

(rule ((ContextOf e a))
      ((delete (ContextOf e a)))
      :ruleset debug-deletes)

(rule ((ExprIsResolved e))
      ((delete (ExprIsResolved e)))
      :ruleset debug-deletes)

(rule ((bop->string a b))
      ((delete (bop->string a b)))
      :ruleset debug-deletes)

(rule ((bpred-of-type a b))
      ((delete (bpred-of-type a b)))
      :ruleset debug-deletes)

(rule ((PureType e))
      ((delete (PureType e)))
      :ruleset debug-deletes)

(rule ((PointsToCells a b))
      ((delete (PointsToCells a b)))
      :ruleset debug-deletes)

(rule ((TuplePointsTo e))
      ((delete (TuplePointsTo e)))
      :ruleset debug-deletes)

(rule ((Resolved-List<PtrPointees> e))
      ((delete (Resolved-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((TypeListToList<PtrPointees> e))
      ((delete (TypeListToList<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<PtrPointees> a b))
      ((delete (Cons-List<PtrPointees> a b)))
      :ruleset debug-deletes)

(rule ((Nil-List<PtrPointees>))
      ((delete (Nil-List<PtrPointees>)))
      :ruleset debug-deletes)

(rule ((Length-List<PtrPointees> e))
      ((delete (Length-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((At-List<PtrPointees> a b c))
      ((delete (At-List<PtrPointees> a b c)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<PtrPointees> a))
      ((delete (IsNonEmpty-List<PtrPointees> a)))
      :ruleset debug-deletes)

(rule ((Resolved-List<i64+IntInterval> e))
      ((delete (Resolved-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<i64+IntInterval> a b c))
      ((delete (Cons-List<i64+IntInterval> a b c)))
      :ruleset debug-deletes)

(rule ((Nil-List<i64+IntInterval>))
      ((delete (Nil-List<i64+IntInterval>)))
      :ruleset debug-deletes)

(rule ((Length-List<i64+IntInterval> e))
      ((delete (Length-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((At-List<i64+IntInterval> a b c d))
      ((delete (At-List<i64+IntInterval> a b c d)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<i64+IntInterval> a))
      ((delete (IsNonEmpty-List<i64+IntInterval> a)))
      :ruleset debug-deletes)

(rule ((TypeList-ith a b))
      ((delete (TypeList-ith a b)))
      :ruleset debug-deletes)

(rule ((InIf a b c))
      ((delete (InIf a b c)))
      :ruleset debug-deletes)
(rule ((InLoop a b))
      ((delete (InLoop a b)))
      :ruleset debug-deletes)
(rule ((InFunc a))
      ((delete (InFunc a)))
      :ruleset debug-deletes)

(rule ((TupleT a))
      ((delete (TupleT a)))
      :ruleset debug-deletes)
(rule ((TCons a b))
      ((delete (TCons a b)))
      :ruleset debug-deletes)
(rule ((TNil))
      ((delete (TNil)))
      :ruleset debug-deletes)
(rule ((Base a))
      ((delete (Base a)))
      :ruleset debug-deletes)
(rule ((IntT))
      ((delete (IntT)))
      :ruleset debug-deletes)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)

(constructor AddContext (Assumption Expr) Expr :unextractable)
(constructor AddContextList (Assumption ListExpr) ListExpr :unextractable)

;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (AddContext ctx inner))
   (= inner (AddContext ctx expr)))
  ((union lhs inner))
  :ruleset context)


;; ############################## Base cases- leaf nodes

;; replace existing contexts that are around leaf nodes
;; AddContext assumes the new context is more specific than the old one
(rule ((= lhs (AddContext ctx (Arg ty oldctx))))
      ((union lhs (Arg ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Const c ty oldctx))))
      ((union lhs (Const c ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Empty ty oldctx))))
      ((union lhs (Empty ty ctx)))
      :ruleset context)




;; ######################################### Operators
(rewrite (AddContext ctx (Top op c1 c2 c3))
         (Top op
           (AddContext ctx c1)
           (AddContext ctx c2)
           (AddContext ctx c3))
               :ruleset context)
(rewrite (AddContext ctx (Bop op c1 c2))
         (Bop op
           (AddContext ctx c1)
           (AddContext ctx c2))
               :ruleset context)
(rewrite (AddContext ctx (Uop op c1))
         (Uop op (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Get c1 index))
         (Get (AddContext ctx c1) index)
               :ruleset context)
(rewrite (AddContext ctx (Alloc id c1 state ty))
         (Alloc id (AddContext ctx c1) (AddContext ctx state) ty)
         :ruleset context)
(rewrite (AddContext ctx (Call name c1))
         (Call name (AddContext ctx c1))
         :ruleset context)

(rewrite (AddContext ctx (Single c1))
         (Single (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Concat c1 c2))
         (Concat
           (AddContext ctx c1)
           (AddContext ctx c2))
         :ruleset context)

;; ################################### List operators

(rewrite (AddContextList ctx (Nil))
         (Nil)
         :ruleset context)

(rewrite (AddContextList ctx (Cons c1 rest))
         (Cons (AddContext ctx c1)
               (AddContextList ctx rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (AddContext ctx (Switch pred inputs branches))
         (Switch (AddContext ctx pred)
                 (AddContext ctx inputs)
                 branches)
         :ruleset context)

;; For stop at region, still add context to inputs
(rule ((= lhs (AddContext ctx (If pred inputs c1 c2))))
      ((union lhs
         (If (AddContext ctx pred)
             (AddContext ctx inputs)
             c1
             c2)))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (AddContext ctx (DoWhile inputs outputs))))
      ((union lhs
        (DoWhile
          (AddContext ctx inputs)
          outputs)))
       :ruleset context)
(ruleset canon)

; Commutativity
(rewrite (Bop (Add) x y) (Bop (Add) y x) :ruleset canon)
(rewrite (Bop (Mul) x y) (Bop (Mul) y x) :ruleset canon)
(rewrite (Bop (Eq) x y) (Bop (Eq) y x) :ruleset canon)
(rewrite (Bop (And) x y) (Bop (And) y x) :ruleset canon)
(rewrite (Bop (Or) x y) (Bop (Or) y x) :ruleset canon)

; Canonicalize to <
; x > y ==> y < x
(rewrite (Bop (GreaterThan) x y) (Bop (LessThan) y x) :ruleset canon)

; x >= y ==> y < x + 1
; x >= y ==> y - 1 < x
(rule (
        (= lhs (Bop (GreaterEq) x y))
        (HasArgType x ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) y (Bop (Add) x (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) y (Const (Int 1) ty ctx)) x))
      )
      :ruleset canon)

; x <= y ==> x < y + 1
; x <= y ==> x - 1 < y
(rule (
        (= lhs (Bop (LessEq) x y))
        (HasArgType y ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) x (Bop (Add) y (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) x (Const (Int 1) ty ctx)) y))
      )
      :ruleset canon)


; Make Concats right-deep
(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)
; Simplify Concat's with empty
(rewrite (Concat (Empty ty ctx) x)
         x
         :ruleset always-run)
(rewrite (Concat x (Empty ty ctx))
         x
         :ruleset always-run)

; Make a tuple that is a sub-range of another tuple
;                   tuple start len
(constructor SubTuple (Expr  i64   i64) Expr :unextractable)

(rewrite (SubTuple expr x 0)
         (Empty ty ctx)
         :when ((HasArgType expr ty) (ContextOf expr ctx))
         :ruleset always-run)

(rewrite (SubTuple expr x 1)
         (Single (Get expr x))
         :ruleset always-run)

(rewrite (SubTuple expr a b)
         (Concat (Single (Get expr a)) (SubTuple expr (+ a 1) (- b 1)))
         :when ((> b 1))
         :ruleset always-run)

; Some of our rules (like ivt.egg) match on `Concat`.
; These may be missing if a tuple is used directly (i.e. (DoWhile inputs (If pred thn else))).
; So add these concats for every region in the database
(rule ((= lhs (DoWhile inputs body))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (If pred inputs thn els))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Switch pred inputs bodies))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Arg ty ctx))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)

; Also figure out what existing expressions are subtuples of other things
; this helps remove concat layers
(rule ((Get expr i))
      ((union (Single (Get expr i))
              (SubTuple expr i 1)))
      :ruleset always-run)

(rewrite (Concat (SubTuple expr a b)
                 (SubTuple expr (+ a b) c))
         (SubTuple expr a (+ b c))
         :ruleset always-run)
;; a subtuple which is the entire tuple is the tuple itself
;; this removes unecessary layers of concat
(rewrite (SubTuple expr 0 len)
         expr
         :when ((= len (tuple-length expr)))
         :ruleset always-run)

; Helper functions to remove one element from a tuple or type list
;                           tuple    idx
(constructor TupleRemoveAt    (Expr     i64) Expr     :unextractable)
(rewrite (TupleRemoveAt tuple idx)
         (Concat (SubTuple tuple 0 idx)
                 (SubTuple tuple (+ idx 1) (- len (+ idx 1))))
         :when ((= len (tuple-length tuple)))
         :ruleset always-run)
(rule ((TupleRemoveAt tuple idx)
       (= len (tuple-length tuple))
       (>= idx len))
      ((panic "Index out of bounds for TupleRemoveAt")) :ruleset always-run)

(constructor TypeListRemoveAt (TypeList i64) TypeList :unextractable)
(rule ((TypeListRemoveAt (TNil) _idx))
      ((panic "Index out of bounds for TypeListRemoveAt.")) :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) 0)
         xs
         :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) idx)
         (TCons x (TypeListRemoveAt xs (- idx 1)))
         :when ((> idx 0))
         :ruleset type-helpers)
