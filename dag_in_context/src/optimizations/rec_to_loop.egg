;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (start[0]) {
;;      do {
;;         inputs = rec_case(start); // first n tuple items
;;         start = always_runs(inputs);
;;      } while (start[0]);
;;    }
;;    ret base_case(start);
;; for example, printBinary sums the results of recursive calls
(rule
  ((Function name in out body)
   (= body (If pred inputs (Call name call-inputs) base-case))
   (HasType inputs inputs-ty)
   (HasType body func-ty))
  ((let loop
     (DoWhile (Arg inputs-ty (InIf true pred inputs))
       (Concat
         (Single (Subst (InIf true pred inputs) call-inputs pred))
         (Subst (InIf true pred inputs) call-inputs inputs))))
    
  ;; initial start value
   (let outer-if
     (If pred inputs
         loop
         (Arg inputs-ty (InIf false pred inputs))))
   (union body (Subst (InFunc name) outer-if base-case)))
  :ruleset rec-to-loop)
