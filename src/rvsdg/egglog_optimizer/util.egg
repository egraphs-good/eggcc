;; ####################################
;; implementation of PassThroughArguments
;; Creates a vec of arguments
;; (vec-of (Arg 0) (Arg 1) ...) with length i
(function PassThroughArguments (i64) VecOperand :unextractable)



;; (how many arguments to generate, vector so far)
(function PassThroughArgumentsHelper (i64 VecOperand) VecOperand :unextractable)

(rewrite (PassThroughArguments i)
  (PassThroughArgumentsHelper i (VO (vec-of)))
  :ruleset subst)

(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))
       (< (vec-length rest) i))
      ((union lhs
        (PassThroughArgumentsHelper i
            (VO (vec-push rest (Arg (vec-length rest)))))))
      :ruleset subst)

(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))
       (= (vec-length rest) i))
      ((union lhs (VO rest)))
      :ruleset subst)



;; Project each argument out of a body
(function BodyToVecOperand (i64 Body) VecOperand :unextractable)
;; current index, body length, body, and vector so far
(function BodyToVecOperandHelper (i64 i64 Body VecOperandBase) VecOperand :unextractable)

(rewrite (BodyToVecOperand body-len body)
         (BodyToVecOperandHelper 0 body-len body (vec-of)))
(rule
  ((= helper (BodyToVecOperandHelper index body-len body so-far))
   (< index body-len))
  ((union helper
          (BodyToVecOperandHelper (+ index 1) body-len body
                                  (vec-push so-far 
                                   (Project index body)))))
  :ruleset subst)

(rule
  ((= helper (BodyToVecOperandHelper index body-len body so-far))
   (= index body-len))
  ((union helper (VO so-far)))
  :ruleset subst)



;; Find equivalent operands that don't include pass-through Gammas
;; This is only sound because it's unextractable; otherwise we would have linearity bugs
;; TODO: (egglog task) make Transparent crash the program on merge instead of staying silent
(function Transparent (Operand) Operand :unextractable :merge new)

;; Base cases:
;; if there are no arguments, it's already transparent
(rule ((= op (Arg _)))
      ((set (Transparent op) op)))
(rule ((= op (Node (PureOp (Const t (const) literal)))))
      ((set (Transparent op) op)))
;; if there are arguments, they have to be transparent-able
(rule ((= op (Node (PureOp (badd t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (badd t x_ y_))))))
(rule ((= op (Node (PureOp (bsub t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bsub t x_ y_))))))
(rule ((= op (Node (PureOp (bmul t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bmul t x_ y_))))))
(rule ((= op (Node (PureOp (bfmul t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bfmul t x_ y_))))))
(rule ((= op (Node (PureOp (bdiv t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bdiv t x_ y_))))))
(rule ((= op (Node (PureOp (beq t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (beq t x_ y_))))))
(rule ((= op (Node (PureOp (blt t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (blt t x_ y_))))))
(rule ((= op (Node (PureOp (bgt t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bgt t x_ y_))))))
(rule ((= op (Node (PureOp (ble t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (ble t x_ y_))))))
(rule ((= op (Node (PureOp (bge t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bge t x_ y_))))))
(rule ((= op (Node (PureOp (bnot t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bnot t x_ y_))))))
(rule ((= op (Node (PureOp (band t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (band t x_ y_))))))
(rule ((= op (Node (PureOp (bor t x y))))
       (= (Transparent x) x_)
       (= (Transparent y) y_))
      ((set (Transparent op) (Node (PureOp (bor t x_ y_))))))

;; Recursive case 1: match on Gamma pass-throughs
;; TODO: generalize to more than two cases (this also applies to all 1.x cases)
(rule ((= op (Project n (Gamma pred (VO ins) (VVO outs))))
       (= (vec-length outs) 2)
       (= (vec-get outs 1) (VO then))
       (= (vec-get outs 0) (VO else))
       (= (vec-get then n) (Arg n))
       (= (vec-get else n) (Arg n)))
      ((set (Transparent op) (vec-get ins n))))

;; Recursive case 1.0: if a project refers to a print, it's definitely not a pass-through
;; TODO: generalize to all operators
(rule ((= op (Project n (Gamma pred (VO ins) (VVO outs))))
       (= (vec-length outs) 2)
       (= (vec-get outs 1) (VO then))
       (= (vec-get outs 0) (VO else))
       (= (vec-get then n) (Node (PureOp (PRINT a b))))
       (= (vec-get else n) (Node (PureOp (PRINT c d)))))
      ((set (Transparent op) op)))

;; Recursive case 1.1: the translator generates constants for tracking which CFG branch
;;                     we're in; we undo this for Transparent
(rule ((= op (Project n (Gamma pred (VO ins) (VVO outs))))
       (= (vec-length outs) 2)
       (= (vec-get outs 1) (VO then))
       (= (vec-get outs 0) (VO else))
       (= (vec-get then n) (Node (PureOp (Const IntT const (Num 1)))))
       (= (vec-get else n) (Node (PureOp (Const IntT const (Num 0))))))
      ((set (Transparent op) pred)))

;; Recursive case 2: match on Theta pass-throughs
;; TODO: the whole case

;; Unit test for Transparent (case 1)
; (let true_ (Node (PureOp (Const (BoolT) (const) (Bool true)))))
; (let seven (Node (PureOp (Const (IntT) (const) (Num 7)))))
; (let one (Node (PureOp (Const (IntT) (const) (Num 1)))))
; (let eight1 (Node (PureOp (badd (IntT) seven one))))
; (let gamma (Gamma true_
;                   (VO (vec-of seven))
;                   (VVO (vec-of (VO (vec-of (Arg 0))) (VO (vec-of (Arg 0)))))))
; (let eight2 (Node (PureOp (badd (IntT) (Project 0 gamma) one))))
; (run 20)
; (check (= (Transparent eight2) eight1))

;; Unit test for Transparent (case 1.0)
;; We make up a fake print edge to pass around
; (let print_ (Node (PureOp (Const (IntT) (const) (Num -1)))))
; (let true_ (Node (PureOp (Const (BoolT) (const) (Bool true)))))
; (let zero (Node (PureOp (Const (IntT) (const) (Num 0)))))
; (let one (Node (PureOp (Const (IntT) (const) (Num 1)))))
; (let gamma (Gamma true_
;                   (VO (vec-of print_))
;                   (VVO (vec-of (VO (vec-of (Node (PureOp (PRINT zero (Arg 0))))))
;                                (VO (vec-of (Node (PureOp (PRINT one  (Arg 0))))))))))
; (let project (Project 0 gamma))
; (run 20)
; (check (= (Transparent project) project))

;; Unit test for Transparent (case 1.1)
; (let true_ (Node (PureOp (Const (BoolT) (const) (Bool true)))))
; (let zero (Node (PureOp (Const (IntT) (const) (Num 0)))))
; (let one (Node (PureOp (Const (IntT) (const) (Num 1)))))
; (let gamma (Gamma true_
;                   (VO (vec-of))
;                   (VVO (vec-of (VO (vec-of zero)) (VO (vec-of one))))))
; (let project (Project 0 gamma))
; (run 20)
; (check (= (Transparent project) true_))
