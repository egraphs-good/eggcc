//! A pass over a CFG returned from the RVSDG=>CFG [conversion module](crate::rvsdg::to_cfg)
//! to simplify branch structures.
//!
//! # Introduction
//!
//! RVSDGs are more structured than arbitrary CFGs. The only control strutures
//! that RVSDGs support directly are ifs (with an else) and tail-controlled
//! loops. This means that any other control flow constructs, from `for` loops
//! all the way to `goto`s need to be simulated using auxiliary predicate
//! variables introduced during translation time.
//!
//! The resulting representation is great for declarative rewrites, but can
//! generate slower code when directly interpreted as a CFG, e.g. to break out
//! of multiple layers of nested loop, CFGs only require a single jump but
//! RVSDGs require a branch for every layer of nesting.
//!
//! The algorithm in this module aims to recover more natural, efficient
//! control-flow structure from the raw CFG generated by an RVSDG. This module
//! is inspired by the PCFR algorithm described in "Perfect Reconstructability
//! of Control Flow from Demand Dependence Graphs" by Bahman, Reissmann, Jahre,
//! and Meyer, but with some changes:
//!
//!  * PCFR operates on the RVSDG directly, while this algorithm operates on the
//!  resulting CFG.
//!  * PCFR seems to rely on an RVSDG in _predicate continuation form_, where
//!  predicates are introduced immediately before they are used. While it is
//!  possible that eggcc preserves this property, we weren't able to convince
//!  ourselves of it. The algorithm in this module is robust to some predicates
//!  being reordered around (e.g.) effectful operations.
//!  * The algorithm in this module has not been optimized for efficiency and as
//!  a result is likely slower than a good implementation of PCFR. This doesn't
//!  seem like an inherent issue and the performance of the two should be
//!  similar after some optimization.
//!
//! Lastly, the algorithm as written assumes that the CFG has the structure
//! guaranteed by the RVSDG=>CFG conversion: in particular we assume that the
//! CFG is almost in SSA form, where the only SSA violations occur in assignment
//! statements that do not lie on the same path through the CFG without
//! traversing a cycle.
//!
//! # Structure
//! TODO

use bril_rs::{Instruction, Literal, ValueOps};
use indexmap::{IndexMap, IndexSet};
use petgraph::{
    algo::dominators,
    graph::{EdgeIndex, NodeIndex},
    visit::NodeIndexable,
    Direction,
};

use crate::cfg::{BasicBlock, BlockName, Branch, BranchOp, CondVal, Identifier, SimpleCfgFunction};

impl SimpleCfgFunction {
    pub(crate) fn simplify_branches(&mut self) {
        // Step 1: compute some information about the CFG.
        // * Find "administrative" nodes.
        // * Find conditional branches.
        let mut branch_meta = self.get_branch_metadata();
        // Step 2: split conditional branches and mark the relevant constants as
        // known in the later nodes. This lets us reuse the builtin dominance
        // algorithm from petgraph, even though we really want to compute edge
        // dominance
        for (id, edge, val) in branch_meta
            .branches
            .iter()
            .flat_map(|(id, edges)| edges.iter().map(move |(edge, val)| (id, *edge, val)))
        {
            let lit = if val.of == 2 {
                if val.val == 0 {
                    Literal::Bool(false)
                } else {
                    Literal::Bool(true)
                }
            } else {
                // Not handling multi-way branches for now.
                continue;
            };
            let node_bound = self.graph.node_bound();
            let (source, target) = self.graph.edge_endpoints(edge).unwrap();
            let weight = self.graph.remove_edge(edge).unwrap();
            let mid = self
                .graph
                .add_node(BasicBlock::empty(BlockName::Placeholder(node_bound)));
            self.graph.add_edge(source, mid, weight);
            // NB: We rely on the optimize_direct_jumps pass to collapse this back down.
            self.graph.add_edge(
                mid,
                target,
                Branch {
                    op: BranchOp::Jmp,
                    pos: None,
                },
            );
            branch_meta
                .constants_known
                .add_constant(mid, id.clone(), lit);
        }
        // Step 3: Compute dominators for the graph. We'll use this for step 4 and step 5.
        let doms = dominators::simple_fast(&self.graph, self.entry);

        // Step 4: Propagate known values through `id` instructions in the CFG.
        let mut worklist = vec![self.entry];
        while let Some(node) = worklist.pop() {
            let block = &self.graph[node];
            for (dst, src) in block.instrs.iter().filter_map(id_assigned) {
                let Some(cs) = branch_meta.constants_known.by_id.get(&src) else {
                    continue;
                };
                // If we are dominated by a block with a known value for `src`,
                // propagate that value to `dst`.
                let mut to_assign = None;
                for (assign_loc, val) in cs {
                    if doms
                        .dominators(node)
                        .into_iter()
                        .flatten()
                        .any(|dom| &dom == assign_loc)
                    {
                        to_assign = Some((node, dst.clone(), val.clone()));
                        break;
                    }
                }
                let Some((node, dst, val)) = to_assign else {
                    continue;
                };
                branch_meta.constants_known.add_constant(node, dst, val);
            }
            // Add all nodes one down the dom tree to the worklist.
            doms.immediately_dominated_by(node)
                .filter(|n| *n != node)
                .for_each(|dom| worklist.push(dom));
        }

        // Step 5: Rewrite branches:
        // * For each administrative node...
        // * For each outgoing branch [edge e1] with cond val `v` for `id`
        // * Check if a predecessor [via edge e2] node is dominated by a node that has `v` as a known value for `id`.
        // * If so, copy the contents of the admin node to that predecessor, and reroute e2 to the target of e1.
        todo!()

        // Step 6: Remove any nodes no longer reachable from the entry.
    }

    fn get_branch_metadata(&self) -> BranchMetadata {
        let mut res = BranchMetadata::default();
        for node in self.graph.node_indices() {
            let block = &self.graph[node];
            if block.instrs.iter().all(is_admin_instr) {
                res.admin_nodes.insert(node);
            }
            for (id, lit) in block.instrs.iter().filter_map(constants_assigned) {
                res.constants_known.add_constant(node, id, lit);
            }
            let mut walker = self
                .graph
                .neighbors_directed(node, Direction::Outgoing)
                .detach();
            while let Some((edge, _)) = walker.next(&self.graph) {
                if let BranchOp::Cond { arg, val, .. } = &self.graph[edge].op {
                    res.branches
                        .entry(arg.clone())
                        .or_default()
                        .insert(edge, *val);
                }
            }
        }
        res
    }
}

#[derive(Default)]
struct BranchMetadata {
    /// Nodes that only contain administrative instructions.
    admin_nodes: IndexSet<NodeIndex>,
    /// Information about known constant values at particular nodes.
    constants_known: ConstantInfo,
    /// Relevant values used as branches.
    branches: IndexMap<Identifier, IndexMap<EdgeIndex, CondVal>>,
}

/// Constants with a known value as of a given node.
///
/// For now, the constants are always booleans, but we keep arbitrary
/// Literals around to make it easier to handle multi-way branches later.
#[derive(Default)]
struct ConstantInfo {
    by_node: IndexMap<NodeIndex, IndexMap<Identifier, Literal>>,
    by_id: IndexMap<Identifier, Vec<(NodeIndex, Literal)>>,
}

impl ConstantInfo {
    fn add_constant(&mut self, node: NodeIndex, id: Identifier, lit: Literal) {
        if self
            .by_node
            .entry(node)
            .or_default()
            .insert(id.clone(), lit.clone())
            .is_none()
        {
            self.by_id.entry(id).or_default().push((node, lit));
        }
    }
}

/// "Administrative Instructions" are ones that will have essentially no runtime
/// cost once they go through instruction selection / register allocation. We
/// use these as a heuristic to find blocks that are safe to merge into their
/// predecessors in exchange for simpler control flow: RVSDG conversion overhead
/// is largely contained in blocks only containing these instructions.
fn is_admin_instr(inst: &Instruction) -> bool {
    matches!(
        inst,
        Instruction::Constant { .. }
            | Instruction::Value {
                op: ValueOps::Id,
                ..
            }
    )
}

fn constants_assigned(inst: &Instruction) -> Option<(Identifier, Literal)> {
    if let Instruction::Constant {
        dest,
        value: value @ Literal::Bool(..),
        ..
    } = inst
    {
        Some((dest.into(), value.clone()))
    } else {
        None
    }
}

fn id_assigned(inst: &Instruction) -> Option<(Identifier, Identifier)> {
    if let Instruction::Value {
        dest,
        op: ValueOps::Id,
        args,
        ..
    } = inst
    {
        assert_eq!(args.len(), 1);
        Some((dest.into(), args[0].clone().into()))
    } else {
        None
    }
}
