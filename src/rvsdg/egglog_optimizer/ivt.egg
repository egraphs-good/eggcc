;; IVT (aka if/loop inversion) equates programs of the form
;;   do {
;;     if (<pred>) {
;;         <if-case>
;;     } else {
;;         <else-case>
;;     }
;;   } while(<pred>);
;; With those of the form:
;;   if (<pred>) {
;;     do {
;;         <if-case>
;;     } while (<pred>)
;;   } else {
;;     <else-case>
;;   }
(ruleset basechange)

;; BaseChange op from to traverses 'op' recursively and replaces instances of
;; (Project i from) with (Project i to).
(function BaseChangeOperand (Operand Body Body) Operand :unextractable)
(function BaseChangeExpr (Epxr Body Body) Expr :unextractable)
(function BaseChangeBody (Body Body Body) Body :unextractable)
(function BaseChangeVecOperand (VecOperand Body Body) Body :unextractable)
(function BaseChangeVecVecOperand (VecVecOperand Body Body) Body :unextractable)
; 
; ; TODO: fill outputs-aligned in, and populate the upto relation
; ; (outputs-aligned v b) is there if (vec-get v i) = (Proj i b)
; 
; (rule ((= loop (Theta pred loop-in loop-out))
;        (= inner-gamma (Gamma pred gamma-in (VVO gamma-out)))
;        (= 2 (vec-length gamma-out)))
;       ((let then-case (OperandGroup (vec-get gamma-out 1)))
;        ; What is loop-in though? What if it exceeds gamma-in, then we need to extend gamma-in!
;        (let inner-loop  (Theta pred loop-in (BaseChangeVecOperand gamma-in inner-gamma then-case)))
;        (let outer-gamma (Gamma 
;                (SubstOperandAll loop-in pred) 
;                (SubstVecOperandAll loop-in gamma-in)
;                (VVO (vec-of (vec-get gamma-out 0) 
;                             inner-loop))))
;        ; TODO: do we need to do this for every pred, or is unioning the regions
;        ; enough?                        
;        (union outer-gamma loop)))

(rewrite (BaseChangeExpr (Const ty ops lit) from to) (Const ty ops lit) :ruleset subst)
(rewrite (BaseChangeExpr (Call ty f args n-outs) from to) (Call ty f (BaseChangeVecOperand args from to) n-outs) :ruleset subst)
(rewrite (BaseChangeExpr (badd ty a b) from to) (badd ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bsub ty a b) from to) (bsub ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bmul ty a b) from to) (bmul ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bdiv ty a b) from to) (bdiv ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (beq ty a b) from to) (beq ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (blt ty a b) from to) (blt ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bgt ty a b) from to) (bgt ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (ble ty a b) from to) (ble ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bge ty a b) from to) (bge ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bnot ty a b) from to) (bnot ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (band ty a b) from to) (band ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bor ty a b) from to) (bor ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (PRINT a b) from to) (PRINT (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)

(rewrite (BaseChangeOperand (Arg x) from to) (Arg x) :ruleset subst)
(rewrite (BaseChangeOperand (Node from) from to) (Node to) :ruleset subst)
(rewrite (BaseChangeOperand (Project i from) from to) (Project i to) :ruleset subst)

(rewrite (BaseChangeBody (PureOp e) from to) (PureOp (BaseChangeExpr e from to)) :ruleset subst)
(rewrite (BaseChangeBody (Gamma pred inputs outputs) from to) 
    (Gamma (BaseChangeOperand pred from to) (BaseChangeVecOperand inputs from to) outputs) :ruleset subst)
(rewrite (BaseChangeBody (Theta pred inputs outputs) from to) 
    (Theta pred (BaseChangeVecOperand inputs from to) outputs) :ruleset subst)    

(function BaseChangeVecOperandHelper (VecOperand Body Body i64) Body :unextractable)
(rewrite (BaseChangeVecOperand ops from to) (BaseChangeVecOperandHelper ops from to 0) :ruleset subst)
(rule
  ((= f (BaseChangeVecOperandHelper (VO vec) x v i))
   (< i (vec-length vec)))
  ((union
     (BaseChangeVecOperandHelper (VO vec) x v i)
     (BaseChangeVecOperandHelper
       (VO (vec-set vec i (BaseChangeOperand (vec-get vec i) x v)))
       x v (+ i 1)))) :ruleset subst)

(rule
  ((= f (BaseChangeVecOperandHelper (VO vec) x v i))
   (= i (vec-length vec)))
  ((union (BaseChangeVecOperandHelper (VO vec) x v i) (VO vec))) :ruleset subst)

(function BaseChangeVecVecOperandHelper (VecVecOperand Body Body i64) VecVecOperand :unextractable)
(rewrite (BaseChangeVecVecOperand vec from to) (BaseChangeVecVecOperandHelper vec from to 0) :ruleset subst)
(rule
  ((= f (BaseChangeVecVecOperandHelper (VVO vec) from to i))
   (< i (vec-length vec)))
  ((union
     (BaseChangeVecVecOperandHelper (VVO vec) from to i)
     (BaseChangeVecVecOperandHelper
       (VVO (vec-set vec i (BaseChangeVecOperand (vec-get vec i) from to)))
       from to (+ i 1)))) :ruleset subst)

(rule
  ((= f (BaseChangeVecVecOperandHelper (VVO vec) from to i))
   (= i (vec-length vec)))
  ((union (BaseChangeVecVecOperandHelper (VVO vec) from to i) (VVO vec))) :ruleset subst)