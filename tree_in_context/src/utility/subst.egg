(ruleset subst)


;; (Subst new-ctx scope to in) substitutes `to` for `(Arg scope ty)` in `in`, copying equalities
;; to new-ctx as the new equality relation.
(function Subst (Assume Scope Expr Expr) Expr :unextractable)

(rewrite (Subst assum scope to in)
         (DoSubst (Nil) (AssumeCons assum (AssumeNil))
           scope to in)
         :ruleset subst)

;; (DoSubst seen-exprs seen-contexts new-ctx scope to in) substitutes 
;; (InContext current-ctx to) for `(Arg scope ty)` in `in`
;; It also replaces `(Asuume anything (Arg scope ty))` with `(InContext assumption to)`
;; It keeps track of a list of scopes it has seen (loop, let, ect) and the new contexts for those scopes.
;; `seen-exprs` and `seen-contexts` are parallel lists, but `seen-contexts` has one more element (the most current ctx)
(function DoSubst (ListExpr ListAssume Scope Expr Expr) Expr :unextractable)
(function DoSubstList (ListExpr ListAssume Scope Expr ListExpr) ListExpr :unextractable)


;; Base case- leaf nodes
(rewrite (DoSubst seen (AssumeCons ctx other-seen) scope to (Arg scope ty))
         (InContext ctx to)
         :ruleset subst)
;; use of != here is okay since scopes are never unioned
(rule ((= lhs (DoSubst seen (AssumeCons ctx other-seen) scope to (Arg scope2 ty)))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen (AssumeCons ctx other-seen) scope to (InContext ctx2 (Arg scope ty)))
         (InContext ctx to)
         :ruleset subst)
(rule ((= lhs (DoSubst seen (AssumeCons ctx other-seen) scope to (InContext ctx2 (Arg scope2 ty))))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen (AssumeCons ctx other-seen) scope to (Const constant))
         (InContext ctx (Const constant))
         :ruleset subst)
(rewrite (DoSubst seen (AssumeCons ctx other-seen) scope to (InContext ctx2 (Const constant)))
         (InContext ctx (Const constant))
         :ruleset subst)

(rewrite (DoSubst seen (AssumeCons ctx other-seen) ctx scope to (Empty))
         (InContext ctx (Empty))
          :ruleset subst)
(rewrite (DoSubst seen (AssumeCons ctx other-seen) scope to (InContext ctx2 (Empty)))
         (InContext ctx (Empty))
         :ruleset subst)


;; ######################################################## Operators
(rewrite (DoSubst seen seen-ctxs scope to (Bop op c1 c2))
         (Bop op (DoSubst seen seen-ctxs scope to c1)
                 (DoSubst seen seen-ctxs scope to c2))
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (Uop op c1))
         (Uop op (DoSubst seen seen-ctxs scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (Get c1 index))
         (Get (DoSubst seen seen-ctxs scope to c1) index)
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (Alloc c1 ty))
         (Alloc (DoSubst seen seen-ctxs scope to c1) ty)
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (Call name c1))
         (Call name (DoSubst seen seen-ctxs scope to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (DoSubst seen seen-ctxs scope to (Single c1))
         (Single (DoSubst seen seen-ctxs scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (Concat order c1 c2))
         (Concat order (DoSubst seen seen-ctxs scope to c1) (DoSubst seen seen-ctxs scope to c2))
         :ruleset subst)


;; #####################################################   Control flow
(rewrite (DoSubst seen seen-ctxs scope to (Switch pred branches))
         (Switch (DoSubst seen seen-ctxs scope to pred)
                 (DoSubstList seen seen-ctxs scope to branches))
         :ruleset subst)
(rewrite (DoSubst seen seen-ctxs scope to (If pred c1 c2))
         (If (DoSubst seen seen-ctxs scope to pred)
             (DoSubst seen seen-ctxs scope to c1)
             (DoSubst seen seen-ctxs scope to c2))
         :ruleset subst)

;; For let args, just DoSubstitute into the inputs of a let
(rewrite (DoSubst seen seen-ctxs (LetScope) to (Let in out))
         (Let (DoSubst seen seen-ctxs (LetScope) to in)
              out)
         :ruleset subst)
;; For other args, we need to DoSubstitute into both
;; and create a new context for the child
(rule ((= lhs (DoSubst seen seen-ctxs scope to (Let in out)))
       (!= scope (LetScope)))
      ((let new-inputs
          (DoSubst seen seen-ctxs ctx scope to in))
       (let new-ctx
          (InLet new-inputs))
       (union lhs
        (Let new-inputs
            (DoSubst (Cons lhs seen) (AssumeCons new-ctx seen-ctxs) scope to out))))
         :ruleset subst)

;; DoSubstitute just into inputs for loop scopes
(rewrite (DoSubst seen seen-ctxs (LoopScope) to (DoWhile in out))
         (DoWhile (DoSubst seen seen-ctxs (LoopScope) to in)
                  out)
         :ruleset subst)
;; Subsiitute just into inputs for let scopes
(rewrite (DoSubst seen seen-ctxs (LetScope) to (DoWhile in out))
         (DoWhile (DoSubst seen seen-ctxs (LetScope) to in)
                   out)
          :ruleset subst)
;; DoSubstitute into inputs and outputs for fuction scopes
;; also create new context
(rule ((= lhs (DoSubst seen seen-ctxs (FuncScope) to (DoWhile in out))))
      ((let new-inputs
        (DoSubst seen seen-ctxs (FuncScope) to in))
       (let new-ctx
         (InLoop new-inputs out))
       (union lhs
        (DoWhile new-inputs
         (DoSubst (Cons lhs seen) (AssumeListCons new-ctx seen-ctxs) (FuncScope) to out))))
       :ruleset subst)

;; List operators
(rewrite (DoSubstList seen seen-ctxs scope to (Cons c1 c2))
         (Cons (DoSubst seen seen-ctxs scope to c1)
               (DoSubstList seen seen-ctxs scope to c2))
         :ruleset subst)
(rewrite (DoSubstList seen seen-ctxs scope to (Nil))
         (Nil)
         :ruleset subst)

;; ##########################  Saturation
;; This rule ensures saturation by detecting cycles and making contexts equivalent as a result.
;; If a DoSubstitution has seen the same eclass twice, it has passed through a cycle.
;; Therefore, the two contexts are the same.
(rule ((DoSubst (Cons most-recent others)
                (AssumeCons most-recent-ctx other-ctxs)
                scope to expr)
       ;; other eclasses contains most recent eclass
       (= (ListExpr-ith others some_index) most-recent)
       ;; find the corresponding ctx
       (= (ListAssume-ith other-ctxs (+ 1 some_index)) other-ctx))
      ((union most-recent-ctx other-ctx))
      :ruleset subst)

;; demand ith helpers
(rule ((DoSubst seen seen-ctxs scope to expr))
      ((DemandListExpr-ith seen)
       (DemandListAssume-ith seen-ctxs))
      :ruleset subst)
