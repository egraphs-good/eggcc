(ruleset loop-unroll)


;; Loop unrolling is fairly simple,
;; but we must be careful about evaluation
;; order and effects.
;; For example, the predicate and outputs
;; must be evalutaed together, so we
;; use a "NewLet" to bind them together.
(rule
  ((= lhs (Loop id inputs pred-outputs))
   (ExprIsValid lhs)
   (= pred-outputs (All seq-or-parallel pred-outputs-list))
   (= length (ListExpr-length pred-outputs-list)))
  ((let outputs (SubArgList 1 length))
   (union lhs
    ;; NewLet to deep copy everything
    (NewLet ;; let to bind inputs
      (Id (i64-fresh!))
      inputs
      (Let ;; evaluate the pred and outputs
        aid
        pred-outputs
        ;; check the pred, run loop if true
        (Switch
          (Get aarg 0)
          (Pair
            ;; if pred is false, return outputs
            outputs
            ;; inputs to loop are outputs of last iteration
            (Loop aid outputs pred-outputs)))))))
   :ruleset loop-unroll
   :name "loop-unrolling")

