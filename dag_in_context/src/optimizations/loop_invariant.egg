;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(relation is-inv-Expr (Expr Expr))
(relation is-inv-ListExpr (Expr ListExpr))

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr body list) ) 
      ((is-inv-ListExpr-helper body list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper body list i)
       (is-inv-Expr body (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper body list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper body list i)
       (= i (ListExpr-length list)))
    ((is-inv-ListExpr body list)) :ruleset always-run)


(ruleset boundary-analysis)
(ruleset boundary-analysis-prep)

;; We use a function so that we choose just one
;; thing to hoist at a time
;; This is an evil hack!
;                   loop-body invariant-expr
(function to-hoist (Expr) Expr :merge new)

;; pick a random invariant expression
(rule ((is-inv-Expr body expr))
      ((set (to-hoist body) expr)) :ruleset boundary-analysis-prep)

;; pick a bigger one if possible
(rule ((is-inv-Expr body expr)
       (= current (to-hoist body))
       (> (Expr-size expr) (Expr-size current)))
      ((set (to-hoist body) expr)) :ruleset boundary-analysis)

;; mock function
(ruleset loop-inv-motion)

(rule ((= (to-hoist body) inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in body))
       ;; the outter assumption of the loop 
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= len (tuple-length in))
       (= iter-guess (LoopNumItersGuess in body)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))

       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (TmpCtx))
       (let new_out_branch (Get (Arg new_input_type assum) len))

       ;; this two subst only change arg to arg with new type
       (let substed_body
         (Subst assum
               (SubTuple (Arg new_input_type assum) 0 len) body))
       (let inv_in_new_loop
            (Subst assum (SubTuple (Arg new_input_type assum) 0 len) inv))
       (let new_body (Concat substed_body (Single new_out_branch)))
       
       (let new_loop (DoWhile new_input new_body))
       (union assum (InLoop new_input new_body))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in body)) 
       (delete (TmpCtx))
       (set (LoopNumItersGuess new_input new_body) iter-guess)
      )
       :ruleset loop-inv-motion)
