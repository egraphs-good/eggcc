(ruleset type-analysis)

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  (FuncT Type Type)
  (TupleT TypeList)
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)

(function TypeList-length (TypeList) i64)
(function TypeList-ith (TypeList i64) Type :unextractable)
(function TypeList-suffix (TypeList i64) TypeList :unextractable)

(rule ((TupleT tylist)) ((union (TypeList-suffix tylist 0) tylist)) :ruleset type-analysis)

(rule ((= (TypeList-suffix top n) (TCons hd tl)))
    ((union (TypeList-ith top n) hd)
     (union (TypeList-suffix top (+ n 1)) tl)) :ruleset type-analysis)

(rule ((= (TypeList-suffix list n) (TNil)))
    ((set (TypeList-length list) n)) :ruleset type-analysis)

(relation HasType (Expr Type))

; Primitives
(rule ((Num id n))
      ((HasType (Num id n) (IntT)))
      :ruleset type-analysis)

(rule ((Boolean id b))
      ((HasType (Boolean id b) (BoolT)))
      :ruleset type-analysis)

; Pure Op Compute
(rule (
       (Add x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Add x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (Sub x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Sub x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (Mul x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Mul x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (LessThan x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (LessThan x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (And x y)
       (HasType x (BoolT))
       (HasType y (BoolT))
      )
      (
       (HasType (And x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Or x y)
       (HasType x (BoolT))
       (HasType y (BoolT))
      )
      (
       (HasType (Or x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Not x)
       (HasType x (BoolT))
      )
      (
       (HasType (Not x) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Get e n)
       (HasType e (TupleT tylist))
      )
      ((HasType (Get e n) (TypeList-ith tylist n)))
      :ruleset type-analysis)

; Effectful Ops
(rule ((Print e))
      ((HasType (Print e) (TupleT (TNil))))
      :ruleset type-analysis)
; TODO: Read and Write (requires type annotations)

; Switch 
; if the condition is a boolean, it must have exactly two branches
(rule (
       (= switch (Switch cond (Cons A (Cons B (Nil)))))
       (HasType cond (BoolT))
       (HasType A ty)
       (HasType B ty)
      )
      ((HasType switch ty))
      :ruleset type-analysis)

; Otherwise, the condition must be an integer, and we can have any number of branches.

(rule ((Switch cond (Cons branch rest)))
      ((Switch cond rest))                ; peel off a branch for type checking
      :ruleset type-analysis)

; base case- single branch switch has type of branch
(rule (
       (Switch cond (Cons branch (Nil)))
       ; boolean condition handled above, now we must have an integer condition
       (HasType cond (IntT))
       (HasType branch ty)
      )
      ((HasType (Switch cond (Cons branch (Nil))) ty))
      :ruleset type-analysis)
; recursive case
(rule (
       (Switch cond (Cons branch rest))
       (HasType (Switch cond rest) ty)
       ; make sure the condition is an integer
       ; (prevents us from typing boolean switches with >2 branches)
       (HasType cond (IntT))
       (HasType branch ty)
      )
      ((HasType (Switch cond (Cons branch rest)) ty))
      :ruleset type-analysis)

; Sequencing
(rule ((All id ord (Cons hd tl)))
      ((All id ord tl))                ; peel off a layer for type checking
      :ruleset type-analysis)
; base case: Nil
(rule ((All id ord (Nil)))
      ((HasType (All id ord (Nil)) (TupleT (TNil))))
      :ruleset type-analysis)
; rec case
(rule (
       (All id ord (Cons hd tl))
       (HasType hd ty)
       (HasType (All id ord tl) (TupleT tylist))
      )
      ((HasType (All id ord (Cons hd tl)) (TupleT (TCons ty tylist))))
      :ruleset type-analysis)

; If an expr has two different types, panic
(rule (
       (HasType e t1)
       (HasType e t2)
       (!= t1 t2)
      )
      ((panic "Type Mismatch!"))
      :ruleset type-analysis)


; Lets

(rule (
       (Let id in out)
       (HasType in ty)
      )
      (
       (HasType (Arg id) ty) ; assert the let's argument has type ty in the let's context
      )
      :ruleset type-analysis)

(rule (
       (Let id in out)
       (HasType out ty)
      )
      ((HasType (Let id in out) ty))
      :ruleset type-analysis)

; Loops

(rule (
       (Loop id in pred-out)
       (HasType in ty)
      )
      (
       (HasType (Arg id) ty) ; assert the argument has type ty in the loop's context
      )
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType in ty) ; input type
       ; pred-out must be a two-element tuple.
       ; pred must be boolean, output type must match input type
       (HasType pred-out (TupleT (TCons (BoolT) (TCons ty (TNil)))))
      )
      ((HasType (Loop id in pred-out) ty)) ; whole loop has type of output
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType pred-out (TupleT (TCons pred-ty rest)))
       (!= pred-ty (BoolT))
      )
      ((panic "Loop predicate was not a boolean"))
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType in in-ty)
       (HasType pred-out (TupleT lst))
       (!= (TypeList-length lst) 2)
      )
      ((panic "Loop did not get two arguments (predicate and output)"))
      :ruleset type-analysis)