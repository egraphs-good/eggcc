;; Substitution
(ruleset subst)

;;                   e  [ x -> v ]
(function SubstExpr (Expr i64 Operand) Expr :unextractable)
(function SubstOperand (Operand i64 Operand) Operand :unextractable)
(function SubstBody (Body i64 Operand) Body :unextractable)
(function SubstVecOperand (VecOperand i64 Operand) VecOperand :unextractable)
(function SubstVecVecOperand (VecVecOperand i64 Operand) VecVecOperand :unextractable)

(rewrite (SubstExpr (Const ty ops lit) x v) (Const ty ops lit) :ruleset subst)
(rewrite (SubstExpr (Call ty f args n-outs) x v) (Call ty f (SubstVecOperand args x v) n-outs) :ruleset subst)
(rewrite (SubstExpr (badd ty a b) x v) (badd ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bsub ty a b) x v) (bsub ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bmul ty a b) x v) (bmul ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bdiv ty a b) x v) (bdiv ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (beq ty a b) x v) (beq ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (blt ty a b) x v) (blt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bgt ty a b) x v) (bgt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (ble ty a b) x v) (ble ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bge ty a b) x v) (bge ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bnot ty a b) x v) (bnot ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (band ty a b) x v) (band ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bor ty a b) x v) (bor ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (PRINT a b) x v) (PRINT (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)

(rewrite (SubstOperand (Arg x) x v) v :ruleset subst)
(rule ((= f (SubstOperand (Arg y) x v)) (!= y x))
      ((union f (Arg y))) :ruleset subst)
(rewrite (SubstOperand (Node b) x v) (Node (SubstBody b x v)) :ruleset subst)
(rewrite (SubstOperand (Project i b) x v) (Project i (SubstBody b x v)) :ruleset subst)

(rewrite (SubstBody (PureOp e) x v) (PureOp (SubstExpr e x v)) :ruleset subst)
;; Subst doesn't cross regions - so we subst into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (SubstBody (Gamma pred inputs outputs) x v) (Gamma (SubstOperand pred x v) (SubstVecOperand inputs x v) outputs) :ruleset subst)
(rewrite (SubstBody (Theta pred inputs outputs) x v) (Theta pred (SubstVecOperand inputs x v) outputs) :ruleset subst)

;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecOperandHelper (VecOperand i64 Operand i64) VecOperand :unextractable)
(rewrite (SubstVecOperand vec x v) (SubstVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecOperandHelper (VO vec) x v i)
      (SubstVecOperandHelper
        (VO (vec-set vec i (SubstOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecOperandHelper (VO vec) x v i) (VO vec))
  ) :ruleset subst)


;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecVecOperandHelper (VecVecOperand i64 Operand i64) VecVecOperand :unextractable)
(rewrite (SubstVecVecOperand vec x v) (SubstVecVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecVecOperandHelper (VVO vec) x v i)
      (SubstVecVecOperandHelper
        (VVO (vec-set vec i (SubstVecOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecVecOperandHelper (VVO vec) x v i) (VVO vec))
  ) :ruleset subst)
 
;; SubstAll - Simultaneous substitutions
;;
;; Instead of substituting a particular argument for an operand, the "*All"
;; variants substitute (Arg i) for (vec-get v i) for a vector `v` passed in as the
;; first argument.

(function SubstExprAll          (VecOperand Expr)          Expr :unextractable)
(function SubstOperandAll       (VecOperand Operand)       Operand :unextractable)
(function SubstBodyAll          (VecOperand Body)          Body :unextractable)
(function SubstVecOperandAll    (VecOperand VecOperand)    VecOperand :unextractable)
(function SubstVecVecOperandAll (VecOperand VecVecOperand) VecVecOperand :unextractable)

(rewrite (SubstExprAll x (Const ty ops lit)) (Const ty ops lit) :ruleset subst)
(rewrite (SubstExprAll x (Call ty f args n-outs)) (Call ty f (SubstVecOperandAll x args) n-outs) :ruleset subst)
(rewrite (SubstExprAll x (badd ty a b)) (badd ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bsub ty a b)) (bsub ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bmul ty a b)) (bmul ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bdiv ty a b)) (bdiv ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (beq ty a b)) (beq ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (blt ty a b)) (blt ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bgt ty a b)) (bgt ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (ble ty a b)) (ble ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bge ty a b)) (bge ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bnot ty a b)) (bnot ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (band ty a b)) (band ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bor ty a b)) (bor ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (PRINT a b)) (PRINT (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)

(rule ((= res (SubstOperandAll (VO ops) (Arg x)))
       (< x (vec-length ops)))
      ((union res (vec-get ops x))) :ruleset subst)
;; NB: unclear if this rule is needed      
(rule ((= res (SubstOperandAll (VO ops) (Arg x)))
       (>= x (vec-length ops)))
      ((union res (Arg x))) :ruleset subst)
(rewrite (SubstOperandAll x (Node b)) (Node (SubstBodyAll x b)) :ruleset subst)
(rewrite (SubstOperandAll x (Project i b)) (Project i (SubstBodyAll x b)) :ruleset subst)

(rewrite (SubstBodyAll x (PureOp e)) (PureOp (SubstExprAll x e)) :ruleset subst)
;; Subst doesn't cross regions - so we subst into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (SubstBodyAll x (Gamma pred inputs outputs)) 
  (Gamma (SubstOperandAll x pred) (SubstVecOperandAll x inputs) outputs) :ruleset subst)
(rewrite (SubstBodyAll x (Theta pred inputs outputs)) 
  (Theta pred (SubstVecOperandAll x inputs) outputs) :ruleset subst)

;; params: substs, vec, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecOperandAllHelper (VecOperand VecOperand i64) VecOperand :unextractable)
(rewrite (SubstVecOperandAll x vec) (SubstVecOperandAllHelper x vec 0) :ruleset subst)
(rule
  ((= f (SubstVecOperandAllHelper x (VO vec) i))
   (< i (vec-length vec)))
  ((union
     (SubstVecOperandAllHelper x (VO vec) i)
     (SubstVecOperandAllHelper
       x
       (VO (vec-set vec i (SubstOperandAll x (vec-get vec i))))
       (+ i 1)))) :ruleset subst)

(rule
  ((= f (SubstVecOperandAllHelper x (VO vec) i))
   (= i (vec-length vec)))
  ((union (SubstVecOperandAllHelper x (VO vec) i) (VO vec))) :ruleset subst)


;; params: substs, vec, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecVecOperandAllHelper (VecOperand VecVecOperand i64) VecVecOperand :unextractable)
(rewrite (SubstVecVecOperandAll x vec) (SubstVecVecOperandAllHelper x vec 0) :ruleset subst)
(rule
  ((= f (SubstVecVecOperandAllHelper x (VVO vec) i))
   (< i (vec-length vec)))
  ((union
     (SubstVecVecOperandAllHelper x (VVO vec) i)
     (SubstVecVecOperandAllHelper
       x
       (VVO (vec-set vec i (SubstVecOperandAll x (vec-get vec i))))
       (+ i 1)))) :ruleset subst)

(rule
  ((= f (SubstVecVecOperandAllHelper x (VVO vec) i))
   (= i (vec-length vec)))
  ((union (SubstVecVecOperandAllHelper x (VVO vec) i) (VVO vec))) :ruleset subst)
 