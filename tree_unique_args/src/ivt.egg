(ruleset ivt)

; IVT inverts ifs and loops when their predicates match, e.g.
;
;        do {
;           if (x) Y else Z
;        } while(x);
; 
;        =>
; 
;        if (x) {
;            do {
;                Y
;            } while (x);
;        } else {
;            Z
;        }
;
; The rules here assume that the entire loop body _is_ an if. This of course
; will not match most loops directly: we rely on optimizations that nest
; computations inside of an if for this rule to fire.

;                     switch  inputs
(function LiftSwitch (Expr    Expr)   Expr)
(rewrite (LiftSwitch inner subst) (SubstExpr inner subst) :ruleset always-run)

; Create demand
(rule ((= loop (Loop id in out))
       (= out (All ord (Pair pred switch)))
       (= switch (Switch pred branches))
       (ExprIsPure pred))
      ((LiftSwitch switch in)) :ruleset ivt)

; Apply the rule
(rule ((= loop (Loop id in out))
       (= out (All ord (Pair pred switch)))
       (= switch (Switch pred (Pair thn* els*)))
       (= (Switch pred_ (Pair thn els)) (LiftSwitch switch in)))
      ((let new-id (Id (i64-fresh!)))
       (let inner (NewLoop new-id in (All ord (Pair pred thn*))))
       (let outer (Switch pred_ (Cons inner (Cons els (Nil)))))
       (union loop outer)) :ruleset ivt)