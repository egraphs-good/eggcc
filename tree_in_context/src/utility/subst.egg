(ruleset subst)
(ruleset subst-helpers)




;; ################## 
;; A context path is a list of (eclass, eclass) pairs.
;; In substitution, the path is used to store every context-related eclass we have visited, 
;; and the corresponding expression at that point.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding eclasses are made equivalent.
(datatype ContextPath
  (PathNil)
  (PathCons Expr Expr ContextPath))

(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 hd2 tl)))
      ((Path-contains lhs lhs))
      :ruleset subst-helpers)
(rule ((Path-contains top (PathCons hd1 hd2 tl)))
      ((Path-contains top tl)) :ruleset subst-helpers)


;; (Subst new-ctx scope to in) substitutes `to` for `(Arg scope ty)` in `in`, copying equalities
;; to new-ctx as the new equality relation.
(function Subst (Assumption Scope Expr Expr) Expr :unextractable)

;; (DoSubst cpath new-ctx scope to in) substitutes 
;; (InContext current-ctx to) for `(Arg scope ty)` in `in`
;; It also replaces `(Asuume anything (Arg scope ty))` with `(InContext assumption to)`
;; It keeps track of a list of e-nodes it has seen and the contexts at those points
;; in the `ContextPath`.
;; When an e-node is passed twice, a cycle is detected and so the paths and 
;; corresponding contexts are made equivalent (see util.egg).
(function DoSubst (ContextPath Assumption Scope Expr Expr) Expr :unextractable)
(function DoSubstList (ContextPath Assumption Scope Expr ListExpr) ListExpr :unextractable)
;; Helper for fully instantiating a function's contexts top-down
(relation ExpandFuncContext (Expr))


;; This is the key rule that detects cycles
;; It finds that we have already seen the eclass we are about to substitute into
;; The corresponding eclasses are unioned, and the cyclic
;; substitution is subsumed to ensure saturation.
(rule ((= lhs (DoSubst seen ctx scope to in))
       (Path-contains seen
         (PathCons in original_subst rest)))
      ((union lhs original_subst)
       (subsume (DoSubst seen ctx scope to in))) :ruleset subst-helpers)

;; helper that expands function contexts
;; using substitution
(rule ((ExpandFuncContext (Function name inty outty body)))
  ((union (Function name inty outty body)
    (Function name inty outty (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty) body))))
   :ruleset subst)

;; ExpandFuncContext can fire multiple times, so fix the resulting saturation issue
;; with this identity
(rule
  ((= lhs (DoSubst seen ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (DoSubst seen ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
   :ruleset subst-helpers)

(rule
  ((= lhs (DoSubstList seen ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (DoSubstList seen ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
   :ruleset subst-helpers)

(rule
  ((= lhs (Subst ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (Subst ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
    :ruleset subst-helpers)

;; Another rule essential for ensuring saturation-
;; Since `InLoop` context nodes contain a loop body, substitution
;; can keep creating new contexts where the body has more contextual information.
;; This rule finds this case and makes the two contexts equal.
;; This is sound because the set of reachable states in the loop is the same in both cases
(rule
  ((DoSubst seen nestedctx (FuncScope) (Arg (FuncScope) inty)
     already-substituted) ;; substituting into something already expanded
   (= sinputs (DoSubst seen2 ctx (FuncScope) (Arg (FuncScope) inty) inputs))
   (= already-substituted ;; body already has an InLoop
     (DoSubst seen3 (InLoop sinputs outputs) (FuncScope) (Arg (FuncScope) inty) outputs))
   (= nextedctx ;; the nested context has already-substituted body
      (InLoop sinputs
         already-substituted)))
  ((union nestedctx (InLoop sinputs outputs)))
  :ruleset subst-helpers)
  

;; Subst is sugar for DoSubst
(rewrite (Subst assum scope to in)
         (DoSubst (PathNil) assum scope to in)
         :ruleset subst)


;; Base case- leaf nodes
(rewrite (DoSubst seen ctx scope to (Arg scope ty))
         (InContext ctx to)
         :ruleset subst)
;; use of != here is okay since scopes are never unioned
(rule ((= lhs (DoSubst seen ctx scope to (Arg scope2 ty)))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Arg scope ty)))
         (InContext ctx to)
         :ruleset subst)
(rule ((= lhs (DoSubst seen ctx scope to (InContext ctx2 (Arg scope2 ty))))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Const constant))
         (InContext ctx (Const constant))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Const constant)))
         (InContext ctx (Const constant))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Empty))
         (InContext ctx (Empty))
          :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Empty)))
         (InContext ctx (Empty))
         :ruleset subst)


;; ######################################################## Operators
(rewrite (DoSubst seen ctx scope to (Bop op c1 c2))
         (Bop op (DoSubst seen ctx scope to c1)
                 (DoSubst seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Uop op c1))
         (Uop op (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Get c1 index))
         (Get (DoSubst seen ctx scope to c1) index)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Alloc c1 ty))
         (Alloc (DoSubst seen ctx scope to c1) ty)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Call name c1))
         (Call name (DoSubst seen ctx scope to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (DoSubst seen ctx scope to (Single c1))
         (Single (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Concat order c1 c2))
         (Concat order (DoSubst seen ctx scope to c1) (DoSubst seen ctx scope to c2))
         :ruleset subst)


;; #####################################################   Control flow
(rewrite (DoSubst seen ctx scope to (Switch pred branches))
         (Switch (DoSubst seen ctx scope to pred)
                 (DoSubstList seen ctx scope to branches))
         :ruleset subst)


(rule ((= lhs (DoSubst seen ctx scope to (If pred c1 c2))))
      ((let newpred (DoSubst seen ctx scope to pred))
       (let newpath
        (PathCons (If pred c1 c2) lhs seen))
       (union lhs
        (If newpred
            (DoSubst newpath (InIf true newpred) scope to c1)
            (DoSubst newpath (InIf false newpred) scope to c2))))
         :ruleset subst)

;; For let args, just DoSubstitute into the inputs of a let
(rewrite (DoSubst seen ctx (LetScope) to (Let in out))
         (Let (DoSubst seen ctx (LetScope) to in)
              out)
         :ruleset subst)
;; For other args, we need to DoSubstitute into both
;; and create a new context for the child
(rule ((= lhs (DoSubst seen ctx scope to (Let in out)))
       (!= scope (LetScope)))
      ((let new-inputs
          (DoSubst seen ctx scope to in))
       (let new-ctx
          (InLet new-inputs))
       (union lhs
        (Let new-inputs
            (DoSubst (PathCons (Let in out) lhs seen) new-ctx scope to out))))
         :ruleset subst)

;; DoSubstitute just into inputs for loop scopes
(rewrite (DoSubst seen ctx (LoopScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LoopScope) to in)
                  out)
         :ruleset subst)
;; Subsiitute just into inputs for let scopes
(rewrite (DoSubst seen ctx (LetScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LetScope) to in)
                   out)
          :ruleset subst)
;; DoSubstitute into inputs and outputs for fuction scopes
;; also create new context
(rule ((= lhs (DoSubst seen ctx (FuncScope) to (DoWhile in out))))
      ((let new-inputs
        (DoSubst seen ctx (FuncScope) to in))
       (let new-ctx
         (InLoop new-inputs out))
       (union lhs
        (DoWhile new-inputs
         (DoSubst (PathCons (DoWhile in out) lhs seen) new-ctx (FuncScope) to out))))
       :ruleset subst)

;; List operators
(rewrite (DoSubstList seen ctx scope to (Cons c1 c2))
         (Cons (DoSubst seen ctx scope to c1)
               (DoSubstList seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubstList seen ctx scope to (Nil))
         (Nil)
         :ruleset subst)
