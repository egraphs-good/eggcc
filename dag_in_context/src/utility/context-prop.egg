;; Besides the in_context rules that add fresh contexts to everything,
;; we normalize terms by pushing contexts to leaf nodes.
 
(ruleset context-prop)


(rewrite (InContext ctx (Top op a b c))
         (Top op (InContext ctx a) (InContext ctx b) (InContext ctx c))
         :ruleset context-prop)

(rewrite (InContext ctx (Bop op a b))
         (Bop op (InContext ctx a) (InContext ctx b))
         :ruleset context-prop)

(rewrite (InContext ctx (Uop op a))
         (Uop op (InContext ctx a))
         :ruleset context-prop)

(rewrite (InContext ctx (Get expr ith))
         (Get (InContext ctx expr) ith)
         :ruleset context-prop)

(rewrite (InContext ctx (Alloc i amount state_edge ty))
         (Alloc i (InContext ctx amount) (InContext ctx state_edge) ty)
         :ruleset context-prop)

(rewrite (InContext ctx (Call name arg))
         (Call name (InContext ctx arg))
         :ruleset context-prop)

(rewrite (InContext ctx (Single expr))
         (Single (InContext ctx expr))
         :ruleset context-prop)

(rewrite (InContext ctx (Concat e1 e2))
         (Concat (InContext ctx e1) (InContext ctx e2))
         :ruleset context-prop)

;; then and else are new regions
(rewrite (InContext ctx (If cond inputs then else))
          (If (InContext ctx cond) (InContext ctx inputs) then else)
          :ruleset context-prop)


;; don't add context to body, since it's a new region
(rewrite (InContext ctx (DoWhile inputs body))
         (DoWhile (InContext ctx inputs) body)
         :ruleset context-prop)

;; tie up cycles
(rewrite (InContext ctx (InContext ctx expr))
         (InContext ctx expr)
         :ruleset context-prop)

(rule ((InContext ctx1 (InContext ctx2 expr))
       (!= ctx1 ctx2))
      ((panic "Found nested InContext nodes"))
      :ruleset context-prop)