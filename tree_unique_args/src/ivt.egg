(ruleset ivt)

; IVT inverts ifs and loops when their predicates match, e.g.
;
;        do {
;           if (x) Y else Z
;        } while(x);
; 
;        =>
; 
;        if (x) {
;            do {
;                Y
;            } while (x);
;        } else {
;            Z
;        }
;
; The rules here assume that the entire loop body _is_ an if. This of course
; will not match most loops directly: we rely on optimizations that nest
; computations inside of an if for this rule to fire.

;                     switch  inputs output id
(function LiftSwitch (Expr    Expr   IdSort)     Expr)
(rewrite (LiftSwitch inner subst outer-id) 
         (DeepCopyExpr (SubstExpr inner subst) outer-id) :ruleset always-run)

; Create demand
(rule ((= loop (Loop id in out))
       (ExprHasRefId loop outer-id)
       (ExprIsValid loop)
       (= out (All ord (Cons pred (Cons switch (Nil)))))
       (= switch (Switch pred branches))
       (ExprIsPure pred))
      ((LiftSwitch switch in outer-id)) :ruleset ivt)

; Apply the rule
(rule ((= loop (Loop id in out))
       (ExprIsValid loop)
       (= out (All ord (Cons pred (Cons switch (Nil)))))
       (= switch (Switch pred (Cons thn* (Cons els* (Nil)))))
       ; NB: we don't constrain 'outer-id' here in part because there can only
       ; be _one_ outer-id that is referenced by it. (See the panic in the rules
       ; for *HasRefId).
       (= (Switch pred_ (Cons thn (Cons els (Nil)))) (LiftSwitch switch in outer-id)))
      ((let new-id (Id (i64-fresh!)))
       (let inner (NewLoop new-id in (All ord (Pair pred thn*))))
       (let outer (Switch pred_ (Cons inner (Cons els (Nil)))))
       (union loop outer)) :ruleset ivt)