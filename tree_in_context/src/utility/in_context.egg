; This file propogates in_context nodes top-down from functions.
; It gives each program path a unique equality relation.
; This can be quite expensive, so be careful running these rules.

(ruleset context_propagate)

(sort InContextList)

; Here's a helpful rule that chooses a more specific context over
; an inner, less specific one.
(rewrite (InContext assumption (InContext assumption2 rest))
         (InContext assumption rest)
         :ruleset context_propagate)

; ################### operations
(rewrite (InContext asum (Bop op c1 c2))
         (Bop op (InContext asum c1) (InContext asum c2))
         :ruleset context_propagate)
(rewrite (InContext assum (Uop op c1))
         (Uop op (InContext assum c1))
         :ruleset context_propagate)
(rewrite (InContext assum (Get expr index))
         (Get (InContext assum expr) index)
         :ruleset context_propagate)
(rewrite (InContext assum (Alloc expr ty))
         (Alloc (InContext assum expr) ty)
         :ruleset context_propagate)
(rewrite (InContext assum (Call name expr))
         (Call name (InContext assum expr))
         :ruleset context_propagate)

; ################### tuple operations
(rewrite (InContext assum (Single expr))
         (Single (InContext assum expr))
         :ruleset context_propagate)
(rewrite (InContext assum (Concat order e1 e2))
         (Concat order (InContext assum e1) (InContext assum e2))
         :ruleset context_propagate)

;                       assumptions, predicate, cases,   current case
(function SwitchInContext (InContextList   Expr       ListExpr i64) ListExpr :unextractable) 
;; TODO propogate context for switch statements using substitution