
;; unroll loops
(rule ((= theta (Theta pred (VO inputs) (VO outputs))))
                          ;;            arguments body
      ((let after-one-iter
         (SubstVecOperandAll (VO inputs) (VO outputs)))
       ;; (vec-of (Arg 0) (Arg 1) ...)
       (let pass-through (PassThroughArguments (vec-length outputs)))
       (union theta
          (Gamma
            (SubstOperandAll after-one-iter pred)
            after-one-iter
            (VVO
              (vec-of
                ;; in the false case, we are done
                pass-through
                ;; otherwise do the rest of the loop
                (BodyToVecOperand
                (vec-length outputs)
                (Theta pred pass-through
                            (VO outputs)))))))))

;; remove range checks
;; TODO: this is unsound! it only copies the first output from the inner gamma,
;;       when it should copy all of them
(rule ((= theta (Theta theta_pred (VO theta_inputs) (VO theta_outputs)))
       (= (Transparent theta_pred)
          (Node (PureOp (blt IntT (Arg 0) b))))

       (= (vec-length theta_inputs) 2)
       (= (Transparent (vec-get theta_inputs 1))
          (Node (PureOp (Const IntT const (Num 0)))))

       (= (vec-length theta_outputs) 2)
       (= (Transparent (vec-get theta_outputs 0))
          (Project 0 gamma))
       (= (Transparent (vec-get theta_outputs 1))
          (Node (PureOp (badd IntT
                              (Arg 1)
                              (Node (PureOp (Const IntT const (Num 1))))))))

       (= gamma (Gamma gamma_pred (VO gamma_inputs) (VVO gamma_outputs)))
       (= (Transparent gamma_pred)
          (Node (PureOp (blt IntT (Arg 1) a))))

       (= (vec-get gamma_inputs 0) (Arg 0))

       (= (vec-length gamma_outputs) 2)
       (= (vec-get gamma_outputs 1) (VO then_vec))
       (= (vec-get gamma_outputs 0) (VO else_vec))

       (= (ival a) (IntI a1 a2))
       (= (ival b) (IntI b1 b2))
       (< a2 b1))

      ((let upper (Theta gamma_pred
                         (VO theta_inputs)
                         (VO (vec-of (vec-get then_vec 0) (vec-get theta_outputs 1)))))
       (let lower (Theta theta_pred
                         (PassThroughArguments 2)
                         (VO (vec-of (vec-get else_vec 0) (vec-get theta_outputs 1)))))
       (let final (Gamma theta_pred
                         (VO (vec-of (Project 0 upper) (Project 1 upper)))
                         (VVO (vec-of (VO (vec-of (Project 0 lower) (Project 1 lower)))
                                      (PassThroughArguments 2)))))
       (union theta final)))
