(ruleset loop-strength-reduction)

;; Change multiplication of loop variable to addition to an accumulator
;;
;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a = d
;;     d += c

; Finds invariants/constants within a loop.
; Columns: loop; value of invariant in inputs; value of invariant in outputs
(relation Inv (Expr Expr Expr))
(rule (
    (= loop (Loop id (All input-order inputs) (All predoutput-order (Pair pred (All output-order outputs)))))
    (= (ListExpr-ith outputs i) (Get (Arg id) i)))
    ((Inv loop (ListExpr-ith inputs i) (Get (Arg id) i))) :ruleset always-run)

; NOTE: I removed this rule for now. This is because it is not correct to put
; (Num id n) into the inputs of this loop. It has the id of the loop, so it
; belongs within the context of the outputs, and therefore relies on RefIdOf.
; This note I copied from the previous encoding (unique args) is actually incorrect:
    ;; Note: with the milestone encoding, we had to use
    ;; Body-contains-Operand here. Here, we already know
    ;; that c is within loop because it has the correct id. 
(rule (
    (= c (Num id n))
    (= loop (Loop id inputs predoutputs))
    (ExprHasRefId loop outer-id))
    ((Inv loop (Num outer-id n) c)) :ruleset always-run)

(rule
    (
        ;; Find loop
        (= old-loop (
            Loop
            id
            (All input-order input-list)
            (All predoutput-order
                (Cons
                    pred
                    (Cons
                        (All
                            output-order
                            output-list
                        )
                        (Nil)
                    )
                )))
            )
        (ExprIsValid old-loop)

        ; Find loop variable (argument that gets incremented with a number)
        (= (ListExpr-ith output-list i) (Add (Get (Arg id) i) (Num id loop-incr)))

        ; Find invariant where input is same as output
        (Inv old-loop c-input c-output)

        ; Find multiplication of loop variable and invariant
        (= old-exp (Mul c-output (Get (Arg id) i)))
    )
    (
        ; Generate new id for loop
        (let new-id (Id (i64-fresh!)))

        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Mul c-output (Num id loop-incr)))

        ; n is index of our new, temporary variable d
        (let n (ListExpr-length input-list))

        ; Initial value of d is i * c
        (let d-init (Mul c-input (ListExpr-ith input-list i)))

        ; Value of d in loop
        ; the id here will get replaced in the DeepCopy
        (let d-out (Add (Get (Arg id) n) addend))

        ; Construct optimized loop
        (let new-inputs (All input-order (Append input-list d-init)))
        (let new-outputs (All output-order (Append output-list d-out)))

        (let new-loop
            (NewLoop
                new-id
                new-inputs
                (All
                    predoutput-order
                    (Pair
                        pred
                        new-outputs))))

        ; We can just union within this new loop now
        ; NOTE: milestone encoding used can-subst-beneath for this
        (union (DeepCopyExpr old-exp new-id) (Get (Arg new-id) n))

        ; We need this extra let, because otherwise the ith input will be re-used in the loop
        ; This is not sound for trees if the ith input is impure, and could be inefficient if
        ; the ith input is pure but expensive to compute.
        (let outer-inputs (Append (TODO list of gets from outer id) (ListExpr-ith input-list i)))
        (let outer-let
            (NewLet
            (Id (i64-fresh!))
            outer-inputs
                (
                    NewLet
                    (Id (i64-fresh!))
                    new-loop
                    (TODO list of gets)
                )
            )
        )

        (union old-loop outer-let)
    )
    :ruleset loop-strength-reduction
)