;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    do {
;;      let start = always_runs(inputs);
;;      if (pred) {
;;         inputs = rec_case(start);
;;      } else {
;;         ret base_case(start);
;;      }
;;    }
;; for example, printBinary sums the results of recursive calls
(rule
  ((Function name in out body)
   (= body (If pred inputs (Call name call-inputs) else))
   (HasType body func-ty))
  (
    ;; new if statement doesn't do recursive call
    (let new-if
      (If pred inputs call-inputs else))
    ;; new loop continues on the same predicate
    (let new-loop
      (DoWhile (Arg func-ty (InFunc name))
        (Concat (Single pred) new-if)))
    (union body new-loop)
  )
  :ruleset rec-to-loop)