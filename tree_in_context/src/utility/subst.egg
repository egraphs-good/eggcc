(ruleset subst)
(ruleset subst-helpers)




;; ################## 
;; A context path is a list of (eclass, context) pairs.
;; In substitution, the path is used to store every eclass we have visited, and the context
;; before taking that eclass.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding contexts are inferred to be equal.
(datatype ContextPath
  (PathNil)
  (PathCons Expr Assumption ContextPath))

(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 hd2 tl)))
      ((Path-contains lhs lhs))
      :ruleset subst-helpers)
(rule ((Path-contains top (PathCons hd1 hd2 tl)))
      ((Path-contains top tl)) :ruleset subst-helpers)

;; This is the key rule that detects when contexts are equal
(rule ((= lhs (PathCons node ctx1 rest))
       (Path-contains rest
         (PathCons node ctx2 rest2)))
      ((union ctx1 ctx2)
       (union lhs rest)) :ruleset subst-helpers)

;; (Subst new-ctx scope to in) substitutes `to` for `(Arg scope ty)` in `in`, copying equalities
;; to new-ctx as the new equality relation.
(function Subst (Assumption Scope Expr Expr) Expr :unextractable)

;; (DoSubst cpath new-ctx scope to in) substitutes 
;; (InContext current-ctx to) for `(Arg scope ty)` in `in`
;; It also replaces `(Asuume anything (Arg scope ty))` with `(InContext assumption to)`
;; It keeps track of a list of e-nodes it has seen and the contexts at those points
;; in the `ContextPath`.
;; When an e-node is passed twice, a cycle is detected and so the paths and 
;; corresponding contexts are made equivalent (see util.egg).
(function DoSubst (ContextPath Assumption Scope Expr Expr) Expr :unextractable)
(function DoSubstList (ContextPath Assumption Scope Expr ListExpr) ListExpr :unextractable)
;; Helper for fully instantiating a function's contexts top-down
(relation ExpandFuncContext (Expr))


(rule ((ExpandFuncContext (Function name inty outty body)))
  ((union (Function name inty outty body)
    (Function name inty outty (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty) body))))
   :ruleset subst)

;; ExpandFuncContext can fire multiple times, so fix the resulting saturation issue
;; with this identity
(rule
  ((= lhs (DoSubst seen ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (DoSubst seen ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
   :ruleset subst-helpers)

(rule
  ((= lhs (DoSubstList seen ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (DoSubstList seen ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
   :ruleset subst-helpers)

(rule
  ((= lhs (Subst ctx (FuncScope) (Arg (FuncScope) inty) inner))
   (= inner (Subst ctx (FuncScope) (Arg (FuncScope) inty) expr)))
  ((union lhs inner))
    :ruleset subst-helpers)

(rewrite (Subst assum scope to in)
         (DoSubst (PathNil) assum scope to in)
         :ruleset subst)


;; Base case- leaf nodes
(rewrite (DoSubst seen ctx scope to (Arg scope ty))
         (InContext ctx to)
         :ruleset subst)
;; use of != here is okay since scopes are never unioned
(rule ((= lhs (DoSubst seen ctx scope to (Arg scope2 ty)))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Arg scope ty)))
         (InContext ctx to)
         :ruleset subst)
(rule ((= lhs (DoSubst seen ctx scope to (InContext ctx2 (Arg scope2 ty))))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Const constant))
         (InContext ctx (Const constant))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Const constant)))
         (InContext ctx (Const constant))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Empty))
         (InContext ctx (Empty))
          :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Empty)))
         (InContext ctx (Empty))
         :ruleset subst)


;; ######################################################## Operators
(rewrite (DoSubst seen ctx scope to (Bop op c1 c2))
         (Bop op (DoSubst seen ctx scope to c1)
                 (DoSubst seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Uop op c1))
         (Uop op (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Get c1 index))
         (Get (DoSubst seen ctx scope to c1) index)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Alloc c1 ty))
         (Alloc (DoSubst seen ctx scope to c1) ty)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Call name c1))
         (Call name (DoSubst seen ctx scope to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (DoSubst seen ctx scope to (Single c1))
         (Single (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Concat order c1 c2))
         (Concat order (DoSubst seen ctx scope to c1) (DoSubst seen ctx scope to c2))
         :ruleset subst)


;; #####################################################   Control flow
(rewrite (DoSubst seen ctx scope to (Switch pred branches))
         (Switch (DoSubst seen ctx scope to pred)
                 (DoSubstList seen ctx scope to branches))
         :ruleset subst)


(rule ((= lhs (DoSubst seen ctx scope to (If pred c1 c2))))
      ((let newpred (DoSubst seen ctx scope to pred))
       (let newpath (PathCons (If pred c1 c2) ctx seen))
       (union lhs
        (If newpred
            (DoSubst newpath (InIf true newpred) scope to c1)
            (DoSubst newpath (InIf false newpred) scope to c2))))
         :ruleset subst)

;; For let args, just DoSubstitute into the inputs of a let
(rewrite (DoSubst seen ctx (LetScope) to (Let in out))
         (Let (DoSubst seen ctx (LetScope) to in)
              out)
         :ruleset subst)
;; For other args, we need to DoSubstitute into both
;; and create a new context for the child
(rule ((= lhs (DoSubst seen ctx scope to (Let in out)))
       (!= scope (LetScope)))
      ((let new-inputs
          (DoSubst seen ctx scope to in))
       (let new-ctx
          (InLet new-inputs))
       (union lhs
        (Let new-inputs
            (DoSubst (PathCons (Let in out) ctx seen) new-ctx scope to out))))
         :ruleset subst)

;; DoSubstitute just into inputs for loop scopes
(rewrite (DoSubst seen ctx (LoopScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LoopScope) to in)
                  out)
         :ruleset subst)
;; Subsiitute just into inputs for let scopes
(rewrite (DoSubst seen ctx (LetScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LetScope) to in)
                   out)
          :ruleset subst)
;; DoSubstitute into inputs and outputs for fuction scopes
;; also create new context
(rule ((= lhs (DoSubst seen ctx (FuncScope) to (DoWhile in out))))
      ((let new-inputs
        (DoSubst seen ctx (FuncScope) to in))
       (let new-ctx
         (InLoop new-inputs out))
       (union lhs
        (DoWhile new-inputs
         (DoSubst (PathCons (DoWhile in out) ctx seen) new-ctx (FuncScope) to out))))
       :ruleset subst)

;; List operators
(rewrite (DoSubstList seen ctx scope to (Cons c1 c2))
         (Cons (DoSubst seen ctx scope to c1)
               (DoSubstList seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubstList seen ctx scope to (Nil))
         (Nil)
         :ruleset subst)
