
;; A Perm is a reverse list of integers
;; Applying a permutation allows us to reorder a tuple according to the permutation
(datatype Perm (PermPush i64 Perm) (PNil))
;; expr1 is a list of expressions of the form (Get expr2 i),
;; where all the i's form a permutation
;; The permutation is stored as an expression such that (Subst assum expr2 perm) = expr1
(relation IVTPermutationAnalysisDemand (Expr))
;;                                    expr1 curr  expr2  perm
(relation IVTPermutationAnalysisImpl (Expr  Expr  Expr   Expr))
;;                                expr1 expr2 perm
(relation IVTPermutationAnalysis (Expr Expr Expr))

(rule (
    (DoWhile inpW outW)
) (
    (IVTPermutationAnalysisDemand outW)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisDemand loop-body)
    (= loop-body (Concat (Single (Get expr ith)) rest))
    (HasType expr expr-ty)
) (
    (let perm (Single (Get (Arg expr-ty (InFunc "no-ctx")) ith)))
    (IVTPermutationAnalysisImpl loop-body rest expr perm)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisImpl loop-body curr expr perm)
    (= curr (Concat (Single (Get expr ith)) rest))
    (HasType expr expr-ty)
) (
    (let new-perm (Concat perm (Single (Get (Arg expr-ty (InFunc "no-ctx")) ith))))
    (IVTPermutationAnalysisImpl loop-body rest expr new-perm)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisImpl loop-body (Single last) expr perm)
    (= last (Get expr ith))
    (HasType expr expr-ty)
) (
    (let new-perm (Concat perm (Single (Get (Arg expr-ty (InFunc "no-ctx")) ith))))
    (IVTPermutationAnalysis loop-body expr new-perm)
) :ruleset always-run)


(ruleset loop-inversion)

;; This is for unified handling of thn/els branches
(relation ith-arg-is-bool (Expr Expr Expr i64 Expr Expr))

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    (= conditional (If condI inpI thn els))

    (= (Get thn ith) (Const (Bool true) _unused1 _unused2))
    (= (Get els ith) (Const (Bool false) _unused3 _unused4))
) (
    (ith-arg-is-bool conditional condI inpI ith thn els)
) :ruleset always-run)

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    (= conditional (If condI inpI thn els))

    (= (Get thn ith) (Const (Bool false) _unused1 _unused2))
    (= (Get els ith) (Const (Bool true) _unused3 _unused4))
) (
    ;; TODO: this may introduce overhead, but is the only way to
    ;; not have two rules
    (ith-arg-is-bool conditional (Uop (Not) condI) inpI ith els thn)
) :ruleset always-run)

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    ;; Only handle if statments that have this form:
    ;;   (= conditional (If condI inpI thn els))
    ;;   (= (Get thn ith) (Const (Bool true) _unused1 _unused2))
    ;;   (= (Get els ith) (Const (Bool false) _unused3 _unused4))
    (ith-arg-is-bool conditional condI inpI ith thn els)
    (= (Get outW 0) (Get conditional ith))

    (ContextOf inpW outer-ctx)
    (ContextOf inpI if-ctx)
    (HasType inpI argI)
) (
    ;; first peeled condition
    (let new-if-cond (Subst outer-ctx inpW condI))
    ;; if contexts
    (let new-if-inp (Subst outer-ctx inpW inpI))
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-context (TmpCtx))

    ;; body
    (let new-loop-outputs_ 
        (TupleRemoveAt (Subst if-ctx thn perm) 0))
    (let new-loop-outputs 
        (Subst new-loop-context new-loop-outputs_ 
            (Concat (Single condI) inpI)))

    (let new-loop (DoWhile (Arg argI new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg argI new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let new-expr_
        (Subst outer-ctx new-if els))
    (let new-expr 
        (TupleRemoveAt 
            (Subst outer-ctx new-expr_ perm) 
            0))

    (union new-expr loop)
    (union new-loop-context (InLoop (Arg argI new-if-true-ctx) new-loop-outputs))

    (subsume (DoWhile inpW outW))
    (delete (TmpCtx))
) :ruleset loop-inversion)
