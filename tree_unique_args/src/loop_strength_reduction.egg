(ruleset loop-strength-reduction)

;; Change multiplication of loop variable to addition to an accumulator
;;
;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a = d
;;     d += c

; Finds invariants/constants within a loop.
; Columns: loop; value of invariant in inputs; value of invariant in outputs
(relation Inv (Expr Expr Expr))
(rule (
    (= loop (Loop id (All outer-id input-order inputs) (All id predoutput-order (Pair pred (All id output-order outputs)))))
    (= (ListExpr-ith outputs i) (Get (Arg id) i)))
    ((Inv loop (ListExpr-ith inputs i) (Get (Arg id) i))) :ruleset always-run)

; NOTE: I removed this rule for now. This is because it is not correct to put
; (Num id n) into the inputs of this loop. It has the id of the loop, so it
; belongs within the context of the outputs, and therefore relies on RefIdOf.
; This note I copied from the previous encoding (unique args) is actually incorrect:
    ;; Note: with the milestone encoding, we had to use
    ;; Body-contains-Operand here. Here, we already know
    ;; that c is within loop because it has the correct id. 
(rule (
    (= c (Num id n))
    (= loop (Loop id inputs predoutputs))
    (ExprHasRefId loop outer-id))
    ((Inv loop (Num outer-id n) c)) :ruleset always-run)

(rule
    (
        ;; Find loop
        (= old-loop (
            Loop
            id
            (All outer-context-id input-order input-list)
            (All
                id 
                predoutput-order
                (Cons
                    pred
                    (Cons
                        (All
                            id
                            output-order
                            output-list
                        )
                        (Nil)
                    )
                )))
            )
        (ExprIsValid old-loop)

        ; Find loop variable (argument that gets incremented with a number)
        (= (ListExpr-ith output-list i) (Add (Get (Arg id) i) (Num id loop-incr)))

        ; Find invariant where input is same as output
        (Inv old-loop c-input c-output)

        ; Find multiplication of loop variable and invariant
        (= old-exp (Mul c-output (Get (Arg id) i)))

        ; Get outer id so we can adjust the context of the new loop we create
        ; by passing through the argument from the outer context
        ; (= outer-context-id (ExprHasRefId old-loop))
    )
    (
        ; Generate new id for loop
        (let new-id (Id (i64-fresh!)))

        ; We need this extra let, because otherwise the ith input will be re-used in the loop
        ; This is not sound for trees if the ith input is impure, and could be inefficient if
        ; the ith input is pure but expensive to compute.
        (let outer-let-id (Id (i64-fresh!)))
        (let inner-let-id (Id (i64-fresh!)))

        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Mul c-output (Num id loop-incr)))

        ; n is index of our new, temporary variable d
        (let n (ListExpr-length input-list))

        ; Initial value of d is i * c
        (let d-init (Mul c-input (ListExpr-ith input-list i)))

        ; Value of d in loop
        ; the id here will get replaced in the DeepCopy
        (let d-out (Add (Get (Arg id) n) addend))

        ; Construct optimized loop
        (let new-inputs 
            ; Second, replace the ith input (which was pulled up to the outer let to avoid duplicating it)
            ; by getting the second element of the input pair from the outer let
            (All outer-context-id input-order
                (ListExpr-replace-ith
                ; First, substitute Arg (from outer context) with (Get (Arg) 0), because we're moving
                ; this loop into a new context and need to reference the old context which was passed through
                ; as the first element in a pair in the inputs to the new context (new Let)
                    (SubstListExpr
                        (Append input-list d-init)
                        (Get (Arg outer-let-id) 0))
                    i
                    (Get (Arg outer-let-id) 1))
            )
        )

        (let new-outputs (All new-id output-order (Append output-list d-out)))

        (let new-loop
            (NewLoop
                new-id
                new-inputs ; TODO: we need to replace ith arg with (Get (Arg outer-let-id 1)) AND subst (Arg outer-id) for (Get (Arg outer-let-id) 0)
                (All
                    new-id
                    predoutput-order
                    (Pair
                        pred
                        new-outputs))))

        ; We can just union within this new loop now
        ; NOTE: milestone encoding used can-subst-beneath for this
        (union (DeepCopyExpr old-exp new-id) (Get (Arg new-id) n))


        ; We are pulling up the ith loop input to this new outer context, because we need to 
        ; re-use the ith loop input. For soundness and efficiency, the ith loop input should
        ; only be computed once. We do this by computing it in a new outer let, which also
        ; passes through the Arg from the outer context.
        (let outer-inputs
            (All outer-context-id (Parallel)
                (Pair (Arg outer-context-id) (ListExpr-ith input-list i))
            )
        )
        ; TODO  actually maybe this shouldn't be append, we should just create a pair
        ; of (arg outer context) (list expr ith)
        ; list expr ith should have the right inputs
        ; Ok, then instead of (Get (Arg loop-id? which id?) i) we will use get /??

        (let outer-let
            (NewLet
            outer-let-id
            outer-inputs
                (
                    NewLet
                    inner-let-id
                    new-loop
                    ; Get all but last output (last output is the temporary variable we added)
                    ; TODO: does the order matter?
                    (All inner-let-id (Parallel) (list-of-get-arg outer-let-id n))
                )
            )
        )

        (union old-loop outer-let)
    )
    :ruleset loop-strength-reduction
)