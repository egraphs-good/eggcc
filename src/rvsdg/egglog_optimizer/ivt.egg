;; IVT (aka if/loop inversion) equates programs of the form
;;   do {
;;     if (<pred>) {
;;         <if-case>
;;     } else {
;;         <else-case>
;;     }
;;   } while(<pred>);
;; With those of the form:
;;   if (<pred>) {
;;     do {
;;         <if-case>
;;     } while (<pred>)
;;   } else {
;;     <else-case>
;;   }

;; BaseChange op from to traverses 'op' recursively and replaces instances of
;; (Project i from) with (Project i to).
(function BaseChangeOperand (Operand Body Body) Operand :unextractable)
(function BaseChangeExpr (Expr Body Body) Expr :unextractable)
(function BaseChangeBody (Body Body Body) Body :unextractable)
(function BaseChangeVecOperand (VecOperand Body Body) VecOperand :unextractable)
(function BaseChangeVecVecOperand (VecVecOperand Body Body) VecVecOperand :unextractable)

(relation Body-contains-Body (Body Body))

(rule ((= loop (Theta pred (VO inputs) outputs))
       (= gamma (Gamma pred gamma-in (VVO gamma-out)))
       (Body-contains-Body loop gamma))
      ((let inner-else-block (OperandGroup (SubstVecOperandAll gamma-in (vec-get gamma-out 0))))
       (let outer-else-block (BaseChangeVecOperand outputs gamma inner-else-block))
       (let inner-then-block (OperandGroup (SubstVecOperandAll gamma-in (vec-get gamma-out 1))))
       (let inner-theta (Theta (BaseChangeOperand pred gamma inner-then-block) 
                               (PassThroughArguments (vec-length inputs))
                               (BaseChangeVecOperand outputs gamma inner-then-block)))
       (union loop 
        (Gamma (SubstOperandAll (VO inputs) pred) 
               (VO inputs) 
               (VVO 
                (vec-of 
                    outer-else-block
                    (BodyToVecOperand (vec-length inputs) inner-theta)))))))

(rewrite (BaseChangeExpr (Const ty ops lit) from to) (Const ty ops lit) :ruleset subst)
(rewrite (BaseChangeExpr (Call ty f args n-outs) from to) (Call ty f (BaseChangeVecOperand args from to) n-outs) :ruleset subst)
(rewrite (BaseChangeExpr (badd ty a b) from to) (badd ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bsub ty a b) from to) (bsub ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bmul ty a b) from to) (bmul ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bdiv ty a b) from to) (bdiv ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (beq ty a b) from to) (beq ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (blt ty a b) from to) (blt ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bgt ty a b) from to) (bgt ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (ble ty a b) from to) (ble ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bge ty a b) from to) (bge ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bnot ty a b) from to) (bnot ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (band ty a b) from to) (band ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (bor ty a b) from to) (bor ty (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)
(rewrite (BaseChangeExpr (PRINT a b) from to) (PRINT (BaseChangeOperand a from to) (BaseChangeOperand b from to)) :ruleset subst)

(rewrite (BaseChangeOperand (Arg x) from to) (Arg x) :ruleset subst)
(rewrite (BaseChangeOperand (Node from) from to) (Node to) :ruleset subst)
(rewrite (BaseChangeOperand (Project i from) from to) (Project i to) :ruleset subst)

(rewrite (BaseChangeBody (PureOp e) from to) (PureOp (BaseChangeExpr e from to)) :ruleset subst)
(rewrite (BaseChangeBody (OperandGroup vo) from to) (OperandGroup (BaseChangeVecOperand vo from to)) :ruleset subst)
(rewrite (BaseChangeBody (Gamma pred inputs outputs) from to) 
    (Gamma (BaseChangeOperand pred from to) (BaseChangeVecOperand inputs from to) outputs) :ruleset subst)
(rewrite (BaseChangeBody (Theta pred inputs outputs) from to) 
    (Theta pred (BaseChangeVecOperand inputs from to) outputs) :ruleset subst)    

(function BaseChangeVecOperandHelper (VecOperand Body Body i64) VecOperand :unextractable)
(rewrite (BaseChangeVecOperand ops from to) (BaseChangeVecOperandHelper ops from to 0) :ruleset subst)
(rule
  ((= f (BaseChangeVecOperandHelper (VO vec) x v i))
   (< i (vec-length vec)))
  ((union
     (BaseChangeVecOperandHelper (VO vec) x v i)
     (BaseChangeVecOperandHelper
       (VO (vec-set vec i (BaseChangeOperand (vec-get vec i) x v)))
       x v (+ i 1)))) :ruleset subst)

(rule
  ((= f (BaseChangeVecOperandHelper (VO vec) x v i))
   (= i (vec-length vec)))
  ((union (BaseChangeVecOperandHelper (VO vec) x v i) (VO vec))) :ruleset subst)

(function BaseChangeVecVecOperandHelper (VecVecOperand Body Body i64) VecVecOperand :unextractable)
(rewrite (BaseChangeVecVecOperand vec from to) (BaseChangeVecVecOperandHelper vec from to 0) :ruleset subst)
(rule
  ((= f (BaseChangeVecVecOperandHelper (VVO vec) from to i))
   (< i (vec-length vec)))
  ((union
     (BaseChangeVecVecOperandHelper (VVO vec) from to i)
     (BaseChangeVecVecOperandHelper
       (VVO (vec-set vec i (BaseChangeVecOperand (vec-get vec i) from to)))
       from to (+ i 1)))) :ruleset subst)

(rule
  ((= f (BaseChangeVecVecOperandHelper (VVO vec) from to i))
   (= i (vec-length vec)))
  ((union (BaseChangeVecVecOperandHelper (VVO vec) from to i) (VVO vec))) :ruleset subst)