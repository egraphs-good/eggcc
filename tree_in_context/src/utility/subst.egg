(ruleset subst)


;; (Subst new-ctx scope to in) substitutes `to` for `(Arg scope ty)` in `in`, copying equalities
;; to new-ctx as the new equality relation.
(function Subst (Assumption Scope Expr Expr) Expr :unextractable)

;; (DoSubst cpath new-ctx scope to in) substitutes 
;; (InContext current-ctx to) for `(Arg scope ty)` in `in`
;; It also replaces `(Asuume anything (Arg scope ty))` with `(InContext assumption to)`
;; It keeps track of a list of e-nodes it has seen and the contexts at those points
;; in the `ContextPath`.
;; When an e-node is passed twice, a cycle is detected and so the paths and 
;; corresponding contexts are made equivalent (see util.egg).
(function DoSubst (ContextPath Assumption Scope Expr Expr) Expr :unextractable)
(function DoSubstList (ContextPath Assumption Scope Expr ListExpr) ListExpr :unextractable)
;; Helper for fully instantiating a function's contexts top-down
(relation ExpandFuncContext (Expr))


(rule ((ExpandFuncContext (Function name inty outty body)))
  ((union (Function name inty outty body)
    (Function name inty outty (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty) body))))
   :ruleset subst)

;; ExpandFuncContext can fire multiple times, so fix the resulting saturation issue
;; with this identity
(rewrite
  (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty)
    (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty)
      body))
  (Subst (InFunc name) (FuncScope) (Arg (FuncScope) inty)
      body)
   :ruleset subst)


(rewrite (Subst assum scope to in)
         (DoSubst (PathNil) assum scope to in)
         :ruleset subst)


;; Base case- leaf nodes
(rewrite (DoSubst seen ctx scope to (Arg scope ty))
         (InContext ctx to)
         :ruleset subst)
;; use of != here is okay since scopes are never unioned
(rule ((= lhs (DoSubst seen ctx scope to (Arg scope2 ty)))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Arg scope ty)))
         (InContext ctx to)
         :ruleset subst)
(rule ((= lhs (DoSubst seen ctx scope to (InContext ctx2 (Arg scope2 ty))))
       (!= scope scope2))
      ((union lhs
         (InContext ctx (Arg scope2 ty))))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Const constant))
         (InContext ctx (Const constant))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Const constant)))
         (InContext ctx (Const constant))
         :ruleset subst)

(rewrite (DoSubst seen ctx scope to (Empty))
         (InContext ctx (Empty))
          :ruleset subst)
(rewrite (DoSubst seen ctx scope to (InContext ctx2 (Empty)))
         (InContext ctx (Empty))
         :ruleset subst)


;; ######################################################## Operators
(rewrite (DoSubst seen ctx scope to (Bop op c1 c2))
         (Bop op (DoSubst seen ctx scope to c1)
                 (DoSubst seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Uop op c1))
         (Uop op (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Get c1 index))
         (Get (DoSubst seen ctx scope to c1) index)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Alloc c1 ty))
         (Alloc (DoSubst seen ctx scope to c1) ty)
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Call name c1))
         (Call name (DoSubst seen ctx scope to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (DoSubst seen ctx scope to (Single c1))
         (Single (DoSubst seen ctx scope to c1))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (Concat order c1 c2))
         (Concat order (DoSubst seen ctx scope to c1) (DoSubst seen ctx scope to c2))
         :ruleset subst)


;; #####################################################   Control flow
(rewrite (DoSubst seen ctx scope to (Switch pred branches))
         (Switch (DoSubst seen ctx scope to pred)
                 (DoSubstList seen ctx scope to branches))
         :ruleset subst)
(rewrite (DoSubst seen ctx scope to (If pred c1 c2))
         (If (DoSubst seen ctx scope to pred)
             (DoSubst seen ctx scope to c1)
             (DoSubst seen ctx scope to c2))
         :ruleset subst)

;; For let args, just DoSubstitute into the inputs of a let
(rewrite (DoSubst seen ctx (LetScope) to (Let in out))
         (Let (DoSubst seen ctx (LetScope) to in)
              out)
         :ruleset subst)
;; For other args, we need to DoSubstitute into both
;; and create a new context for the child
(rule ((= lhs (DoSubst seen ctx scope to (Let in out)))
       (!= scope (LetScope)))
      ((let new-inputs
          (DoSubst seen ctx scope to in))
       (let new-ctx
          (InLet new-inputs))
       (union lhs
        (Let new-inputs
            (DoSubst (PathCons (LetNode in out) new-ctx seen) new-ctx scope to out))))
         :ruleset subst)

;; DoSubstitute just into inputs for loop scopes
(rewrite (DoSubst seen ctx (LoopScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LoopScope) to in)
                  out)
         :ruleset subst)
;; Subsiitute just into inputs for let scopes
(rewrite (DoSubst seen ctx (LetScope) to (DoWhile in out))
         (DoWhile (DoSubst seen ctx (LetScope) to in)
                   out)
          :ruleset subst)
;; DoSubstitute into inputs and outputs for fuction scopes
;; also create new context
(rule ((= lhs (DoSubst seen ctx (FuncScope) to (DoWhile in out))))
      ((let new-inputs
        (DoSubst seen ctx (FuncScope) to in))
       (let new-ctx
         (InLoop new-inputs out))
       (union lhs
        (DoWhile new-inputs
         (DoSubst (PathCons (DoWhileNode in out) new-ctx seen) new-ctx (FuncScope) to out))))
       :ruleset subst)

;; List operators
(rewrite (DoSubstList seen ctx scope to (Cons c1 c2))
         (Cons (DoSubst seen ctx scope to c1)
               (DoSubstList seen ctx scope to c2))
         :ruleset subst)
(rewrite (DoSubstList seen ctx scope to (Nil))
         (Nil)
         :ruleset subst)
